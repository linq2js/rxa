{"version":3,"sources":["../index.js"],"names":["create","noop","cancellationToken","debounce","f","delay","timerId","clearTimeout","args","setTimeout","parsePath","path","split","pathToLens","createCancellablePromise","promise","isCancellable","ct","cancellablePromise","then","Promise","reject","result","reason","cancel","value","abort","initialState","defState","storageOptions","autoSaveSubscription","autoSave","state","store","getState","localStorage","setItem","key","JSON","stringify","subscribeAutoSave","subscribe","serializedAppData","getItem","parse","defaultReducer","action","actionKey","payload","stateToCompare","v","k","customReducer","Date","getTime","toString","dispatch","actionWrappers","$state","changes","arguments","length","type","dummyDispatch","Math","random","registerActions","parentKey","model","x","originalKey","originalKeyParts","originalActionName","options","Function","Array","actionName","name","actionPath","actionWrapper","currentOptions","dispatchQueue","dispatchStatus","single","lastResult","addToDispatchQueue","callback","push","trigger","dispatchData","types","forEach","i","actionResult","error","executing","success","fail","$async","__asyncOptions","$done","$fail","$success","$current","current","def","ex","asyncOptions","loading","asyncResult","Object","assign","undefined","with","actionLens","app","Provider","props","children","connect","Error","mapper","prefetch","prefetchArgsSelector","identity","reselect","isFetchResult","status","$fetch","connection","dispatchProps","ownProps","to","reducer","subscriber","actions","selector","createSelector","invoke"],"mappings":"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","file":"index.js","sourcesContent":["import React from \"react\";\r\nimport {connect, Provider} from \"react-redux\";\r\nimport {createStore, combineReducers} from \"redux\";\r\nimport {createSelector} from \"reselect\";\r\nimport {\r\n    forEachObjIndexed as each,\r\n    set,\r\n    view,\r\n    lensPath,\r\n    equals,\r\n    map,\r\n    identity,\r\n    contains\r\n} from \"ramda\";\r\n\r\nconst noop = () => {\r\n};\r\nconst cancellationToken = {};\r\n\r\nfunction debounce(f, delay = 0) {\r\n    let timerId;\r\n    return function (...args) {\r\n        clearTimeout(timerId);\r\n        timerId = setTimeout(f, delay, ...args);\r\n    };\r\n}\r\n\r\nfunction parsePath(path) {\r\n    return path.split(/[.[\\]]/);\r\n}\r\n\r\n/**\r\n * create lens from path\r\n */\r\nfunction pathToLens(path) {\r\n    return lensPath(parsePath(path));\r\n}\r\n\r\nfunction createCancellablePromise(promise) {\r\n    if (promise.isCancellable) return promise;\r\n\r\n    let ct;\r\n\r\n    const cancellablePromise = promise.then(\r\n        result => {\r\n            if (ct) {\r\n                return Promise.reject(ct);\r\n            }\r\n            return result;\r\n        },\r\n        reason => {\r\n            return ct || reason;\r\n        }\r\n    );\r\n\r\n    cancellablePromise.cancel = function (value = cancellationToken) {\r\n        if (ct) return this;\r\n        //console.log('cancelled');\r\n        if (promise.abort) {\r\n            promise.abort();\r\n        }\r\n        if (promise.cancel) {\r\n            promise.cancel();\r\n        }\r\n        ct = value;\r\n        return this;\r\n    };\r\n\r\n    cancellablePromise.isCancellable = true;\r\n\r\n    return cancellablePromise;\r\n}\r\n\r\nexport function create(initialState = {}, defState = {}) {\r\n    let storageOptions = {};\r\n    let autoSaveSubscription;\r\n\r\n    function autoSave() {\r\n        const state = store.getState();\r\n        localStorage.setItem(storageOptions.key, JSON.stringify(state));\r\n    }\r\n\r\n    function subscribeAutoSave() {\r\n        if (autoSaveSubscription) {\r\n            autoSaveSubscription();\r\n            if (!storageOptions.key) {\r\n                return;\r\n            }\r\n        }\r\n        autoSaveSubscription = store.subscribe(\r\n            debounce(autoSave, storageOptions.debounce || 200)\r\n        );\r\n    }\r\n\r\n    if (typeof initialState === \"string\") {\r\n        storageOptions = {key: initialState};\r\n\r\n        const serializedAppData = localStorage.getItem(storageOptions.key);\r\n        if (serializedAppData) {\r\n            initialState = JSON.parse(serializedAppData) || defState;\r\n        } else {\r\n            initialState = defState;\r\n        }\r\n    }\r\n\r\n    function defaultReducer(state = initialState, action) {\r\n        // extract action info\r\n        const {[actionKey]: key, payload} = action;\r\n        if (key) {\r\n            // is merge action, merge state and payload\r\n            // need to improve this logic, avoid update call if state is not changed\r\n            if (key === \"@\") {\r\n                // extract properties to compare\r\n                const stateToCompare = map((v, k) => state[k], payload);\r\n                if (equals(stateToCompare, payload)) {\r\n                    return state;\r\n                }\r\n\r\n                return {\r\n                    ...state,\r\n                    ...payload\r\n                };\r\n            }\r\n\r\n            // if there is any change with this key/prop, clone current state and apply the changes\r\n            if (equals(view(pathToLens(key), state), payload)) return state;\r\n\r\n            //console.log(action);\r\n\r\n            return set(pathToLens(key), payload, state);\r\n        }\r\n\r\n        // call custom reducers if any\r\n        return customReducer ? customReducer(state, action) : state;\r\n    }\r\n\r\n    // create random action key\r\n    const actionKey = new Date().getTime().toString();\r\n    const store = createStore(defaultReducer);\r\n\r\n    subscribeAutoSave();\r\n\r\n    function dispatch(action) {\r\n        //console.log('[dispatch]', action);\r\n        store.dispatch(action);\r\n    }\r\n\r\n    let actionWrappers = {\r\n        /**\r\n         * get/update state\r\n         */\r\n        $state(changes) {\r\n            if (arguments.length < 1) return store.getState();\r\n            if (changes) {\r\n                dispatch({\r\n                    type: \"merge\",\r\n                    [actionKey]: \"@\",\r\n                    payload: changes\r\n                });\r\n            }\r\n        }\r\n    };\r\n\r\n    let customReducer = null;\r\n\r\n    function dummyDispatch() {\r\n        dispatch({\r\n            type: \"@dummy\",\r\n            [actionKey]: \"__dummy__\",\r\n            payload: Math.random() * new Date().getTime()\r\n        });\r\n    }\r\n\r\n    function registerActions(parentKey, model) {\r\n        each((x, k) => {\r\n            const originalKey = k;\r\n            const originalKeyParts = originalKey.split(\":\");\r\n            let originalActionName;\r\n            let options = {};\r\n\r\n            // supports named actionName:stateProp\r\n            if (originalKeyParts.length > 1) {\r\n                k = originalKeyParts[1];\r\n                originalActionName = originalKeyParts[0];\r\n            }\r\n\r\n            if (parentKey) {\r\n                k = parentKey + \".\" + k;\r\n            }\r\n\r\n            // action setting can be Function or Array\r\n            // prop: Function\r\n            // prop: [actionName, Function]\r\n            if (x instanceof Function || x instanceof Array) {\r\n                // try to get action name\r\n                let actionName = originalActionName || x.name || originalKey;\r\n\r\n                if (x instanceof Array) {\r\n                    options = x[1] || options;\r\n                    if (typeof options === \"string\") {\r\n                        options = {name: options};\r\n                    }\r\n                    actionName = options.name || actionName;\r\n\r\n                    x = x[0];\r\n                }\r\n\r\n                const actionPath = (parentKey ? parentKey + \".\" : \"\") + actionName;\r\n                // create action wrapper\r\n                const actionWrapper = (...args) => {\r\n                    const currentOptions = actionWrapper.options || options;\r\n                    const dispatchQueue = [];\r\n                    delete actionWrapper.options;\r\n\r\n                    if (currentOptions.dispatchStatus) {\r\n                        currentOptions.single = true;\r\n                    }\r\n\r\n                    // cancel prev executing\r\n                    if (\r\n                        currentOptions.single &&\r\n                        actionWrapper.lastResult &&\r\n                        actionWrapper.lastResult.cancel\r\n                    ) {\r\n                        actionWrapper.lastResult.cancel();\r\n                    }\r\n\r\n                    delete actionWrapper.lastResult;\r\n\r\n                    function addToDispatchQueue(type, callback) {\r\n                        dispatchQueue.push({type, callback});\r\n                    }\r\n\r\n                    function trigger(dispatchData, ...types) {\r\n                        dispatchData && dispatch(dispatchData);\r\n\r\n                        dispatchQueue.forEach(i => {\r\n                            if (contains(i.type, types)) {\r\n                                i.callback();\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    const dispatchStatus = !currentOptions.dispatchStatus\r\n                        ? noop\r\n                        : dummyDispatch;\r\n\r\n                    let actionResult;\r\n                    delete actionWrapper.error;\r\n                    actionWrapper.executing = true;\r\n                    actionWrapper.success = false;\r\n                    actionWrapper.fail = false;\r\n\r\n                    try {\r\n                        actionResult = x(...args);\r\n\r\n                        // is lazy call, (...args) => (getState, actions) => actionBody\r\n                        if (actionResult instanceof Function) {\r\n                            actionResult = actionResult({\r\n                                ...actionWrappers,\r\n                                $async(promise, options = {}) {\r\n                                    if (promise && promise.then) {\r\n                                        promise.__asyncOptions = options;\r\n                                    }\r\n                                    return promise;\r\n                                },\r\n                                $done: x => addToDispatchQueue(\"done\", x),\r\n                                $fail: x => addToDispatchQueue(\"fail\", x),\r\n                                $success: x => addToDispatchQueue(\"success\", x),\r\n                                // provide get current value\r\n                                $current: def => {\r\n                                    const state = store.getState();\r\n                                    const current = view(pathToLens(k), state);\r\n                                    if (typeof current === \"undefined\") return def;\r\n                                    return current;\r\n                                }\r\n                            });\r\n                        }\r\n                    } catch (ex) {\r\n                        actionWrapper.fail = true;\r\n                        actionWrapper.error = ex;\r\n                        throw ex;\r\n                    } finally {\r\n                        actionWrapper.executing = false;\r\n                    }\r\n\r\n                    // is then-able object\r\n                    if (actionResult && actionResult.then) {\r\n                        const asyncOptions = actionResult.__asyncOptions;\r\n\r\n                        actionWrapper.executing = true;\r\n\r\n                        actionWrapper.lastResult = actionResult = createCancellablePromise(\r\n                            actionResult\r\n                        );\r\n\r\n                        if (asyncOptions && \"loading\" in asyncOptions) {\r\n                            dispatch({\r\n                                type: actionPath,\r\n                                [actionKey]: k,\r\n                                payload: asyncOptions.loading\r\n                            });\r\n                        }\r\n\r\n                        dispatchStatus();\r\n\r\n                        // handle async action call\r\n                        actionResult.then(\r\n                            asyncResult => {\r\n                                //console.log('[success]');\r\n                                actionWrapper.success = true;\r\n                                actionWrapper.executing = false;\r\n\r\n                                trigger(\r\n                                    {\r\n                                        type: actionPath,\r\n                                        [actionKey]: k,\r\n                                        payload: asyncResult\r\n                                    },\r\n                                    \"success\",\r\n                                    \"done\"\r\n                                );\r\n\r\n                                // make sure state changed if payload is undefined\r\n                                if (typeof payload === \"undefined\") {\r\n                                    dispatchStatus();\r\n                                }\r\n                            },\r\n                            ex => {\r\n                                if (ex === cancellationToken) return;\r\n                                //console.log('[fail]');\r\n                                actionWrapper.executing = false;\r\n                                actionWrapper.fail = true;\r\n                                actionWrapper.error = ex;\r\n\r\n                                if (asyncOptions && \"fail\" in asyncOptions) {\r\n                                    dispatch({\r\n                                        type: actionPath,\r\n                                        [actionKey]: k,\r\n                                        payload: asyncOptions.fail\r\n                                    });\r\n                                }\r\n\r\n                                dispatchStatus();\r\n                                trigger(null, \"fail\", \"done\");\r\n                            }\r\n                        );\r\n                    } else {\r\n                        actionWrapper.success = true;\r\n\r\n                        // handle sync action call\r\n                        trigger(\r\n                            {\r\n                                type: actionPath,\r\n                                [actionKey]: k,\r\n                                payload: actionResult\r\n                            },\r\n                            \"done\"\r\n                        );\r\n                    }\r\n\r\n                    return actionResult;\r\n                };\r\n\r\n                Object.assign(actionWrapper, {\r\n                    success: undefined,\r\n                    fail: undefined,\r\n                    executing: false,\r\n                    with: options => (...args) => {\r\n                        actionWrapper.options = options;\r\n                        return actionWrapper(...args);\r\n                    }\r\n                });\r\n\r\n                const actionLens = pathToLens(actionPath);\r\n\r\n                actionWrappers = set(\r\n                    actionLens,\r\n                    actionWrapper,\r\n                    actionWrappers\r\n                );\r\n\r\n                if (!view(actionLens, app)) {\r\n                    Object.assign(app, actionWrappers)\r\n                }\r\n\r\n\r\n            } else {\r\n                registerActions(k, x);\r\n            }\r\n        }, model);\r\n    }\r\n\r\n    const app = {\r\n        /**\r\n         * create provider\r\n         */\r\n        Provider: props => <Provider store={store}>{props.children}</Provider>,\r\n        autoSave(options = {key: \"appState\"}) {\r\n            if (typeof options === \"string\") {\r\n                options = {key: options};\r\n            }\r\n\r\n            storageOptions = options;\r\n\r\n            subscribeAutoSave();\r\n            return app;\r\n        },\r\n        /**\r\n         * connect component\r\n         * connect(mapper, component)\r\n         * connect(mapper, prefetch, component)\r\n         * connect(mapper, [argsSelector, prefetch], component)\r\n         */\r\n        connect(...args) {\r\n            if (args.length < 1) {\r\n                throw new Error(\"Argument count mismatch\");\r\n            }\r\n            let mapper, prefetch, prefetchArgsSelector;\r\n            if (args.length === 1) {\r\n                [mapper] = args;\r\n            } else if (args.length === 2) {\r\n                [mapper, prefetch] = args;\r\n            } else if (args.length === 3) {\r\n                [mapper, prefetchArgsSelector, prefetch] = args;\r\n            }\r\n\r\n            // prefetch enabled\r\n            if (prefetch) {\r\n                prefetch = createSelector(prefetch, identity);\r\n\r\n                if (prefetchArgsSelector) {\r\n                    prefetchArgsSelector = createSelector(prefetchArgsSelector, identity);\r\n                }\r\n            }\r\n\r\n            // create selector to memoize props\r\n            const reselect = createSelector(identity, props => {\r\n                if (prefetch) {\r\n                    let result = prefetchArgsSelector\r\n                        ? prefetch(prefetchArgsSelector(props))\r\n                        : prefetch();\r\n\r\n                    if (result) {\r\n                        if (!result.isFetchResult) {\r\n                            if (result.then) {\r\n                                // init fetching status\r\n                                result.isFetchResult = true;\r\n                                result.status = \"loading\";\r\n                                result.loading = true;\r\n\r\n                                // handle async fetching\r\n                                result.then(\r\n                                    x => {\r\n                                        result.success = true;\r\n                                        result.loading = false;\r\n                                        result.status = \"success\";\r\n                                        result.payload = x;\r\n                                        dummyDispatch();\r\n                                    },\r\n                                    x => {\r\n                                        result.fail = true;\r\n                                        result.loading = false;\r\n                                        result.status = \"fail\";\r\n                                        result.payload = x;\r\n                                        dummyDispatch();\r\n                                    }\r\n                                );\r\n                            } else {\r\n                                result = {\r\n                                    isFetchResult: true,\r\n                                    status: \"success\",\r\n                                    success: true,\r\n                                    payload: result\r\n                                };\r\n                            }\r\n                        } else {\r\n                            // do not touch\r\n                        }\r\n                    } else {\r\n                        result = {\r\n                            status: \"success\",\r\n                            success: true,\r\n                            payload: result\r\n                        };\r\n                    }\r\n\r\n                    // clone fetching result to make sure mergedProps changed\r\n                    if (result && result.then && (result.success || result.fail)) {\r\n                        result = {\r\n                            isFetchResult: true,\r\n                            fail: result.fail,\r\n                            success: result.success,\r\n                            status: result.status,\r\n                            payload: result.payload\r\n                        };\r\n                    }\r\n\r\n                    props.$fetch = result;\r\n                }\r\n                return props;\r\n            });\r\n            const connection = connect(\r\n                state => ({state}),\r\n                null,\r\n                ({state}, dispatchProps, ownProps) =>\r\n                    reselect(mapper(state, actionWrappers, ownProps)) || ownProps\r\n            );\r\n\r\n            // add shortcut 'to'\r\n            connection.to = connection;\r\n\r\n            return connection;\r\n        },\r\n        /**\r\n         * register single action\r\n         */\r\n        action(key, action, options) {\r\n            if (!(action instanceof Function)) {\r\n                options = action;\r\n                action = identity;\r\n            }\r\n\r\n            registerActions(null, set(pathToLens(key), [action, options], {}));\r\n            return app;\r\n        },\r\n        /**\r\n         * add custom reducers. This is helpful for 3rd lib which need reducer (Router, Log...)\r\n         */\r\n        reducer(value) {\r\n            customReducer =\r\n                value instanceof Function ? value : combineReducers(value);\r\n            return app;\r\n        },\r\n        /**\r\n         * dispatch custom action\r\n         */\r\n        dispatch(...args) {\r\n            dispatch(...args);\r\n            return app;\r\n        },\r\n        debounce,\r\n        /**\r\n         *\r\n         */\r\n        subscribe(subscriber) {\r\n            return store.subscribe((...args) =>\r\n                subscriber(store.getState(), ...args)\r\n            );\r\n        },\r\n        /**\r\n         * register multiple actions\r\n         */\r\n        actions(model) {\r\n            registerActions(null, model);\r\n            return app;\r\n        },\r\n        /**\r\n         * create new selector\r\n         */\r\n        selector(...args) {\r\n            return createSelector(...args);\r\n        },\r\n        /**\r\n         * get current state\r\n         */\r\n        getState() {\r\n            return store.getState();\r\n        },\r\n        /**\r\n         *\r\n         */\r\n        invoke(actionPath, ...args) {\r\n            //console.log('[test]', actionPath);\r\n            const action = view(pathToLens(actionPath), actionWrappers);\r\n            return action(...args);\r\n        }\r\n    };\r\n\r\n    return app;\r\n}"]}