{"version":3,"sources":["../index.js"],"names":["create","Field","form","validateForm","noop","cancellationToken","fieldArrayMethods","split","debounce","f","delay","timerId","clearTimeout","args","setTimeout","parsePath","path","toString","pathToLens","createCancellablePromise","promise","isCancellable","ct","cancellablePromise","then","Promise","reject","result","reason","cancel","value","abort","initialState","defState","storageOptions","autoSaveSubscription","autoSave","state","store","getState","localStorage","setItem","key","JSON","stringify","subscribeAutoSave","subscribe","serializedAppData","getItem","parse","defaultReducer","action","actionKey","payload","stateToCompare","v","k","customReducer","Date","getTime","dispatch","actionWrappers","$state","changes","arguments","length","type","dummyDispatch","Math","random","registerActions","parentKey","model","x","originalKey","originalKeyParts","originalActionName","options","Function","Array","actionName","name","actionPath","actionWrapper","currentOptions","dispatchQueue","dispatchStatus","single","lastResult","addToDispatchQueue","callback","push","trigger","dispatchData","types","forEach","i","actionResult","error","executing","success","fail","$async","__asyncOptions","$done","$fail","$success","$current","current","def","ex","asyncOptions","loading","asyncResult","Object","assign","undefined","with","actionLens","app","Provider","props","children","connect","Error","mapper","prefetch","prefetchArgsSelector","identity","reselect","isFetchResult","status","$fetch","connection","dispatchProps","ownProps","to","reducer","subscriber","actions","selector","createSelector","invoke","$binder","$name","Comp","$comp","$props","customProps","params","comp","formMeta","data","formRender","initialData","meta","onReset","e","preventDefault","formChangeWrapper","onChange","onSubmit","formSubmitWrapper","fieldArray","fieldName","method","newData","newMeta","changeType","field","fieldRender","fieldLens","fieldView","fieldMeta","fields","updateValue","newValue","triggerChange","dirty","updateMeta","renderField","render","onMetaChange","onValueChange","formData","fieldValue","onFocus","touched","focus","stopPropagation","target","onBlur","FormMessage","onValidate","validatingFieldCount","validationCancelled","validating","invalid","valid","warning","cancelValidation","forEachField","info","updateValidationStatus","tryToTriggerMetaChange","formValidationResolve","validate","messageType","done","asyncError","fieldValidationResolve","validateOnSubmit","handleMetaChange","deep","processField","items","some","sf","n","executor","map","item","index","subMeta","subValue","copyOfValue","subData","metaItems","splice","indexesToRemove","filter","pop","shift","unshift","fromIndex","toIndex","sourceIndex","targetIndex","tempMeta","tempItem","newItems","pairs","sortExpression","propSelector","inputComparator","comparator","ascend","descend","sortedPairs"],"mappings":"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","file":"index.js","sourcesContent":["import React from \"react\";\r\nimport { connect, Provider } from \"react-redux\";\r\nimport { createStore, combineReducers } from \"redux\";\r\nimport { createSelector } from \"reselect\";\r\nimport {\r\n    forEachObjIndexed,\r\n    set,\r\n    view,\r\n    lensPath,\r\n    equals,\r\n    map,\r\n    identity,\r\n    contains,\r\n    ascend,\r\n    descend,\r\n    compose,\r\n    prop,\r\n    sort\r\n} from \"ramda\";\r\n\r\nconst noop = () => {};\r\nconst cancellationToken = {};\r\nconst fieldArrayMethods = \"append prepend push pop shift unshift remove removeAt sort swap removeAll move\".split(\r\n    \" \"\r\n);\r\n\r\nfunction debounce(f, delay = 0) {\r\n    let timerId;\r\n    return function(...args) {\r\n        clearTimeout(timerId);\r\n        timerId = setTimeout(f, delay, ...args);\r\n    };\r\n}\r\n\r\nfunction parsePath(path) {\r\n    return path.toString().split(/[.[\\]]/);\r\n}\r\n\r\n/**\r\n * create lens from path\r\n */\r\nfunction pathToLens(path) {\r\n    return lensPath(parsePath(path));\r\n}\r\n\r\nfunction createCancellablePromise(promise) {\r\n    if (promise.isCancellable) return promise;\r\n\r\n    let ct;\r\n\r\n    const cancellablePromise = promise.then(\r\n        result => {\r\n            if (ct) {\r\n                return Promise.reject(ct);\r\n            }\r\n            return result;\r\n        },\r\n        reason => {\r\n            return ct || reason;\r\n        }\r\n    );\r\n\r\n    cancellablePromise.cancel = function(value = cancellationToken) {\r\n        if (ct) return this;\r\n        //console.log('cancelled');\r\n        if (promise.abort) {\r\n            promise.abort();\r\n        }\r\n        if (promise.cancel) {\r\n            promise.cancel();\r\n        }\r\n        ct = value;\r\n        return this;\r\n    };\r\n\r\n    cancellablePromise.isCancellable = true;\r\n\r\n    return cancellablePromise;\r\n}\r\n\r\nexport function create(initialState = {}, defState = {}) {\r\n    let storageOptions = {};\r\n    let autoSaveSubscription;\r\n\r\n    function autoSave() {\r\n        const state = store.getState();\r\n        localStorage.setItem(storageOptions.key, JSON.stringify(state));\r\n    }\r\n\r\n    function subscribeAutoSave() {\r\n        if (autoSaveSubscription) {\r\n            autoSaveSubscription();\r\n            if (!storageOptions.key) {\r\n                return;\r\n            }\r\n        }\r\n        autoSaveSubscription = store.subscribe(\r\n            debounce(autoSave, storageOptions.debounce || 200)\r\n        );\r\n    }\r\n\r\n    if (typeof initialState === \"string\") {\r\n        storageOptions = { key: initialState };\r\n\r\n        const serializedAppData = localStorage.getItem(storageOptions.key);\r\n        if (serializedAppData) {\r\n            initialState = JSON.parse(serializedAppData) || defState;\r\n        } else {\r\n            initialState = defState;\r\n        }\r\n    }\r\n\r\n    function defaultReducer(state = initialState, action) {\r\n        // extract action info\r\n        const { [actionKey]: key, payload } = action;\r\n        if (key) {\r\n            // is merge action, merge state and payload\r\n            // need to improve this logic, avoid update call if state is not changed\r\n            if (key === \"@\") {\r\n                // extract properties to compare\r\n                const stateToCompare = map((v, k) => state[k], payload);\r\n                if (equals(stateToCompare, payload)) {\r\n                    return state;\r\n                }\r\n\r\n                return {\r\n                    ...state,\r\n                    ...payload\r\n                };\r\n            }\r\n\r\n            // if there is any change with this key/prop, clone current state and apply the changes\r\n            if (equals(view(pathToLens(key), state), payload)) return state;\r\n\r\n            //console.log(action);\r\n\r\n            return set(pathToLens(key), payload, state);\r\n        }\r\n\r\n        // call custom reducers if any\r\n        return customReducer ? customReducer(state, action) : state;\r\n    }\r\n\r\n    // create random action key\r\n    const actionKey = new Date().getTime().toString();\r\n    const store = createStore(defaultReducer);\r\n\r\n    subscribeAutoSave();\r\n\r\n    function dispatch(action) {\r\n        //console.log('[dispatch]', action);\r\n        store.dispatch(action);\r\n    }\r\n\r\n    let actionWrappers = {\r\n        /**\r\n         * get/update state\r\n         */\r\n        $state(changes) {\r\n            if (arguments.length < 1) return store.getState();\r\n            if (changes) {\r\n                dispatch({\r\n                    type: \"merge\",\r\n                    [actionKey]: \"@\",\r\n                    payload: changes\r\n                });\r\n            }\r\n        }\r\n    };\r\n\r\n    let customReducer = null;\r\n\r\n    function dummyDispatch() {\r\n        dispatch({\r\n            type: \"@dummy\",\r\n            [actionKey]: \"__dummy__\",\r\n            payload: Math.random() * new Date().getTime()\r\n        });\r\n    }\r\n\r\n    function registerActions(parentKey, model) {\r\n        forEachObjIndexed((x, k) => {\r\n            const originalKey = k;\r\n            const originalKeyParts = originalKey.split(\":\");\r\n            let originalActionName;\r\n            let options = {};\r\n\r\n            // supports named actionName:stateProp\r\n            if (originalKeyParts.length > 1) {\r\n                k = originalKeyParts[1];\r\n                originalActionName = originalKeyParts[0];\r\n            }\r\n\r\n            if (parentKey) {\r\n                k = parentKey + \".\" + k;\r\n            }\r\n\r\n            // action setting can be Function or Array\r\n            // prop: Function\r\n            // prop: [actionName, Function]\r\n            if (x instanceof Function || x instanceof Array) {\r\n                // try to get action name\r\n                let actionName = originalActionName || x.name || originalKey;\r\n\r\n                if (x instanceof Array) {\r\n                    options = x[1] || options;\r\n                    if (typeof options === \"string\") {\r\n                        options = { name: options };\r\n                    }\r\n                    actionName = options.name || actionName;\r\n\r\n                    x = x[0];\r\n                }\r\n\r\n                const actionPath = (parentKey ? parentKey + \".\" : \"\") + actionName;\r\n                // create action wrapper\r\n                const actionWrapper = (...args) => {\r\n                    const currentOptions = actionWrapper.options || options;\r\n                    const dispatchQueue = [];\r\n                    delete actionWrapper.options;\r\n\r\n                    if (currentOptions.dispatchStatus) {\r\n                        currentOptions.single = true;\r\n                    }\r\n\r\n                    // cancel prev executing\r\n                    if (\r\n                        currentOptions.single &&\r\n                        actionWrapper.lastResult &&\r\n                        actionWrapper.lastResult.cancel\r\n                    ) {\r\n                        actionWrapper.lastResult.cancel();\r\n                    }\r\n\r\n                    delete actionWrapper.lastResult;\r\n\r\n                    function addToDispatchQueue(type, callback) {\r\n                        dispatchQueue.push({ type, callback });\r\n                    }\r\n\r\n                    function trigger(dispatchData, ...types) {\r\n                        dispatchData && dispatch(dispatchData);\r\n\r\n                        dispatchQueue.forEach(i => {\r\n                            if (contains(i.type, types)) {\r\n                                i.callback();\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    const dispatchStatus = !currentOptions.dispatchStatus\r\n                        ? noop\r\n                        : dummyDispatch;\r\n\r\n                    let actionResult;\r\n                    delete actionWrapper.error;\r\n                    actionWrapper.executing = true;\r\n                    actionWrapper.success = false;\r\n                    actionWrapper.fail = false;\r\n\r\n                    try {\r\n                        actionResult = x(...args);\r\n\r\n                        // is lazy call, (...args) => (getState, actions) => actionBody\r\n                        if (actionResult instanceof Function) {\r\n                            actionResult = actionResult({\r\n                                ...actionWrappers,\r\n                                $async(promise, options = {}) {\r\n                                    if (promise && promise.then) {\r\n                                        promise.__asyncOptions = options;\r\n                                    }\r\n                                    return promise;\r\n                                },\r\n                                $done: x => addToDispatchQueue(\"done\", x),\r\n                                $fail: x => addToDispatchQueue(\"fail\", x),\r\n                                $success: x => addToDispatchQueue(\"success\", x),\r\n                                // provide get current value\r\n                                $current: def => {\r\n                                    const state = store.getState();\r\n                                    const current = view(pathToLens(k), state);\r\n                                    if (typeof current === \"undefined\") return def;\r\n                                    return current;\r\n                                }\r\n                            });\r\n                        }\r\n                    } catch (ex) {\r\n                        actionWrapper.fail = true;\r\n                        actionWrapper.error = ex;\r\n                        throw ex;\r\n                    } finally {\r\n                        actionWrapper.executing = false;\r\n                    }\r\n\r\n                    // is then-able object\r\n                    if (actionResult && actionResult.then) {\r\n                        const asyncOptions = actionResult.__asyncOptions;\r\n\r\n                        actionWrapper.executing = true;\r\n\r\n                        actionWrapper.lastResult = actionResult = createCancellablePromise(\r\n                            actionResult\r\n                        );\r\n\r\n                        if (asyncOptions && \"loading\" in asyncOptions) {\r\n                            dispatch({\r\n                                type: actionPath,\r\n                                [actionKey]: k,\r\n                                payload: asyncOptions.loading\r\n                            });\r\n                        }\r\n\r\n                        dispatchStatus();\r\n\r\n                        // handle async action call\r\n                        actionResult.then(\r\n                            asyncResult => {\r\n                                //console.log('[success]');\r\n                                actionWrapper.success = true;\r\n                                actionWrapper.executing = false;\r\n\r\n                                trigger(\r\n                                    {\r\n                                        type: actionPath,\r\n                                        [actionKey]: k,\r\n                                        payload: asyncResult\r\n                                    },\r\n                                    \"success\",\r\n                                    \"done\"\r\n                                );\r\n\r\n                                // make sure state changed if payload is undefined\r\n                                if (typeof asyncResult === \"undefined\") {\r\n                                    dispatchStatus();\r\n                                }\r\n                            },\r\n                            ex => {\r\n                                if (ex === cancellationToken) return;\r\n                                //console.log('[fail]');\r\n                                actionWrapper.executing = false;\r\n                                actionWrapper.fail = true;\r\n                                actionWrapper.error = ex;\r\n\r\n                                if (asyncOptions && \"fail\" in asyncOptions) {\r\n                                    dispatch({\r\n                                        type: actionPath,\r\n                                        [actionKey]: k,\r\n                                        payload: asyncOptions.fail\r\n                                    });\r\n                                }\r\n\r\n                                dispatchStatus();\r\n                                trigger(null, \"fail\", \"done\");\r\n                            }\r\n                        );\r\n                    } else {\r\n                        actionWrapper.success = true;\r\n\r\n                        // handle sync action call\r\n                        trigger(\r\n                            {\r\n                                type: actionPath,\r\n                                [actionKey]: k,\r\n                                payload: actionResult\r\n                            },\r\n                            \"done\"\r\n                        );\r\n                    }\r\n\r\n                    return actionResult;\r\n                };\r\n\r\n                Object.assign(actionWrapper, {\r\n                    success: undefined,\r\n                    fail: undefined,\r\n                    executing: false,\r\n                    with: options => (...args) => {\r\n                        actionWrapper.options = options;\r\n                        return actionWrapper(...args);\r\n                    }\r\n                });\r\n\r\n                const actionLens = pathToLens(actionPath);\r\n\r\n                actionWrappers = set(actionLens, actionWrapper, actionWrappers);\r\n\r\n                if (!view(actionLens, app)) {\r\n                    Object.assign(app, actionWrappers);\r\n                }\r\n            } else {\r\n                registerActions(k, x);\r\n            }\r\n        }, model);\r\n    }\r\n\r\n    const app = {\r\n        /**\r\n         * create provider\r\n         */\r\n        Provider: props => <Provider store={store}>{props.children}</Provider>,\r\n        autoSave(options = { key: \"appState\" }) {\r\n            if (typeof options === \"string\") {\r\n                options = { key: options };\r\n            }\r\n\r\n            storageOptions = options;\r\n\r\n            subscribeAutoSave();\r\n            return app;\r\n        },\r\n        /**\r\n         * connect component\r\n         * connect(mapper, component)\r\n         * connect(mapper, prefetch, component)\r\n         * connect(mapper, [argsSelector, prefetch], component)\r\n         */\r\n        connect(...args) {\r\n            if (args.length < 1) {\r\n                throw new Error(\"Argument count mismatch\");\r\n            }\r\n            let mapper, prefetch, prefetchArgsSelector;\r\n            if (args.length === 1) {\r\n                [mapper] = args;\r\n            } else if (args.length === 2) {\r\n                [mapper, prefetch] = args;\r\n            } else if (args.length === 3) {\r\n                [mapper, prefetchArgsSelector, prefetch] = args;\r\n            }\r\n\r\n            // prefetch enabled\r\n            if (prefetch) {\r\n                prefetch = createSelector(prefetch, identity);\r\n\r\n                if (prefetchArgsSelector) {\r\n                    prefetchArgsSelector = createSelector(prefetchArgsSelector, identity);\r\n                }\r\n            }\r\n\r\n            // create selector to memoize props\r\n            const reselect = createSelector(identity, props => {\r\n                if (prefetch) {\r\n                    let result = prefetchArgsSelector\r\n                        ? prefetch(prefetchArgsSelector(props))\r\n                        : prefetch();\r\n\r\n                    if (result) {\r\n                        if (!result.isFetchResult) {\r\n                            if (result.then) {\r\n                                // init fetching status\r\n                                result.isFetchResult = true;\r\n                                result.status = \"loading\";\r\n                                result.loading = true;\r\n\r\n                                // handle async fetching\r\n                                result.then(\r\n                                    x => {\r\n                                        result.success = true;\r\n                                        result.loading = false;\r\n                                        result.status = \"success\";\r\n                                        result.payload = x;\r\n                                        dummyDispatch();\r\n                                    },\r\n                                    x => {\r\n                                        result.fail = true;\r\n                                        result.loading = false;\r\n                                        result.status = \"fail\";\r\n                                        result.payload = x;\r\n                                        dummyDispatch();\r\n                                    }\r\n                                );\r\n                            } else {\r\n                                result = {\r\n                                    isFetchResult: true,\r\n                                    status: \"success\",\r\n                                    success: true,\r\n                                    payload: result\r\n                                };\r\n                            }\r\n                        } else {\r\n                            // do not touch\r\n                        }\r\n                    } else {\r\n                        result = {\r\n                            status: \"success\",\r\n                            success: true,\r\n                            payload: result\r\n                        };\r\n                    }\r\n\r\n                    // clone fetching result to make sure mergedProps changed\r\n                    if (result && result.then && (result.success || result.fail)) {\r\n                        result = {\r\n                            isFetchResult: true,\r\n                            fail: result.fail,\r\n                            success: result.success,\r\n                            status: result.status,\r\n                            payload: result.payload\r\n                        };\r\n                    }\r\n\r\n                    props.$fetch = result;\r\n                }\r\n                return props;\r\n            });\r\n            const connection = connect(\r\n                state => ({ state }),\r\n                null,\r\n                ({ state }, dispatchProps, ownProps) =>\r\n                    reselect(mapper(state, actionWrappers, ownProps)) || ownProps\r\n            );\r\n\r\n            // add shortcut 'to'\r\n            connection.to = connection;\r\n\r\n            return connection;\r\n        },\r\n        /**\r\n         * register single action\r\n         */\r\n        action(key, action, options) {\r\n            if (!(action instanceof Function)) {\r\n                options = action;\r\n                action = identity;\r\n            }\r\n\r\n            registerActions(null, set(pathToLens(key), [action, options], {}));\r\n            return app;\r\n        },\r\n        /**\r\n         * add custom reducers. This is helpful for 3rd lib which need reducer (Router, Log...)\r\n         */\r\n        reducer(value) {\r\n            customReducer =\r\n                value instanceof Function ? value : combineReducers(value);\r\n            return app;\r\n        },\r\n        /**\r\n         * dispatch custom action\r\n         */\r\n        dispatch(...args) {\r\n            dispatch(...args);\r\n            return app;\r\n        },\r\n        debounce,\r\n        /**\r\n         *\r\n         */\r\n        subscribe(subscriber) {\r\n            return store.subscribe((...args) =>\r\n                subscriber(store.getState(), ...args)\r\n            );\r\n        },\r\n        /**\r\n         * register multiple actions\r\n         */\r\n        actions(model) {\r\n            registerActions(null, model);\r\n            return app;\r\n        },\r\n        /**\r\n         * create new selector\r\n         */\r\n        selector(...args) {\r\n            return createSelector(...args);\r\n        },\r\n        /**\r\n         * get current state\r\n         */\r\n        getState() {\r\n            return store.getState();\r\n        },\r\n        /**\r\n         *\r\n         */\r\n        invoke(actionPath, ...args) {\r\n            //console.log('[test]', actionPath);\r\n            const action = view(pathToLens(actionPath), actionWrappers);\r\n            return action(...args);\r\n        }\r\n    };\r\n\r\n    return app;\r\n}\r\n\r\n/**\r\n * Component wrapper for field rendering\r\n */\r\nexport function Field({ $binder, $name, $comp: Comp, $props, ...customProps }) {\r\n    if (!$binder || !$name || !Comp) return null;\r\n    return $binder($name, params => (\r\n        <Comp\r\n            {...params.props}\r\n            {...$props && $props({ name: $name, comp: Comp, ...params })}\r\n            {...customProps}\r\n        />\r\n    ));\r\n}\r\n\r\n/**\r\n * Create form\r\n */\r\nexport function form(formMeta = {}, data, formRender) {\r\n    const initialData = data;\r\n\r\n    return formRender({\r\n        meta: formMeta,\r\n        props: {\r\n            onReset(e) {\r\n                if (e && e.preventDefault) {\r\n                    e.preventDefault();\r\n                }\r\n\r\n                if (formMeta.initialData) {\r\n                    formChangeWrapper(\r\n                        formMeta.initialData,\r\n                        formMeta.initialData,\r\n                        { onChange: formMeta.onChange },\r\n                        \"value\"\r\n                    );\r\n                }\r\n            },\r\n            onSubmit(e) {\r\n                if (e && e.preventDefault) {\r\n                    e.preventDefault();\r\n                }\r\n\r\n                formSubmitWrapper(data, formMeta);\r\n            }\r\n        },\r\n        /**\r\n         * process field array\r\n         */\r\n        fieldArray(fieldName, method, ...args) {\r\n            return fieldArray(\r\n                {\r\n                    meta: formMeta,\r\n                    data,\r\n                    onChange(newData, newMeta, changeType) {\r\n                        formChangeWrapper(initialData, newData, newMeta, changeType);\r\n                    }\r\n                },\r\n                fieldName,\r\n                method,\r\n                args\r\n            );\r\n        },\r\n        // process single field\r\n        field(fieldName, fieldRender) {\r\n            const fieldLens = pathToLens(fieldName);\r\n            const fieldView = view(fieldLens);\r\n            let fieldMeta = fieldView(formMeta.fields);\r\n\r\n            function updateValue(newValue, triggerChange) {\r\n                data = set(fieldLens, newValue, data);\r\n                fieldMeta.dirty = true;\r\n                formMeta.dirty = true;\r\n                if (triggerChange) {\r\n                    formChangeWrapper(initialData, data, formMeta, \"value\");\r\n                }\r\n            }\r\n\r\n            function updateMeta(newMeta, triggerChange) {\r\n                formMeta.fields = set(\r\n                    fieldLens,\r\n                    (fieldMeta = newMeta),\r\n                    formMeta.fields\r\n                );\r\n\r\n                if (triggerChange) {\r\n                    formChangeWrapper(initialData, data, formMeta, \"meta\");\r\n                }\r\n            }\r\n\r\n            // field(name): fieldMeta\r\n            if (arguments.length === 1) {\r\n                return {\r\n                    // value getter/setter\r\n                    value(newValue) {\r\n                        if (!arguments.length) return view(fieldLens, data);\r\n                        updateValue(newValue, true);\r\n                    },\r\n                    // meta getter/setter\r\n                    meta(newMeta) {\r\n                        if (!arguments.length) return fieldMeta || {};\r\n                        if (typeof newMeta === \"string\") {\r\n                            return (fieldMeta || {})[newMeta];\r\n                        }\r\n                        updateMeta(newMeta, true);\r\n                    }\r\n                };\r\n            }\r\n\r\n            if (!fieldMeta) {\r\n                // mutate fields, dont fire meta change event to improve performance\r\n                updateMeta({\r\n                    type: \"field\"\r\n                });\r\n            }\r\n\r\n            return renderField({\r\n                name: fieldName,\r\n                meta: fieldMeta,\r\n                data: data,\r\n                render: fieldRender,\r\n                onMetaChange(newMeta) {\r\n                    updateMeta(newMeta, true);\r\n                },\r\n                onValueChange(newValue) {\r\n                    updateValue(newValue, true);\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nfunction renderField({\r\n                         name,\r\n                         meta: fieldMeta,\r\n                         data: formData,\r\n                         render,\r\n                         onMetaChange,\r\n                         onValueChange\r\n                     }) {\r\n    const fieldView = view(pathToLens(name));\r\n    const fieldValue = fieldView(formData);\r\n    return render({\r\n        name,\r\n        props: {\r\n            onFocus() {\r\n                fieldMeta.touched = true;\r\n                fieldMeta.focus = true;\r\n                onMetaChange(fieldMeta);\r\n            },\r\n            onChange(e) {\r\n                const value =\r\n                    e && e.stopPropagation instanceof Function ? e.target.value : e;\r\n                onValueChange(value);\r\n            },\r\n            onBlur() {\r\n                fieldMeta.focus = false;\r\n                onMetaChange(fieldMeta);\r\n            },\r\n            value: fieldValue\r\n        },\r\n        meta: fieldMeta,\r\n        value: fieldValue\r\n    });\r\n}\r\n\r\nclass FormMessage {\r\n    constructor(data, type = \"error\") {\r\n        this.data = data;\r\n        this.type = type;\r\n    }\r\n}\r\n\r\n/**\r\n * validate form\r\n */\r\nexport function validateForm({\r\n                                 data: formData,\r\n                                 meta: formMeta,\r\n                                 onValidate,\r\n                                 onChange = noop\r\n                             }) {\r\n    return new Promise(formValidationResolve => {\r\n        let validatingFieldCount = 0;\r\n        let validationCancelled = false;\r\n\r\n        formMeta.validating = false;\r\n        formMeta.invalid = false;\r\n        formMeta.valid = true;\r\n        delete formMeta.error;\r\n        delete formMeta.warning;\r\n\r\n        // cancel prev validation\r\n        if (formMeta.cancelValidation instanceof Function) {\r\n            formMeta.cancelValidation();\r\n        }\r\n\r\n        formMeta.cancelValidation = function() {\r\n            validationCancelled = true;\r\n        };\r\n\r\n        // clear field validation\r\n        forEachField(formMeta.fields, false, f => {\r\n            delete f.info;\r\n            delete f.error;\r\n            delete f.warning;\r\n            f.validating = false;\r\n        });\r\n\r\n        if (!onValidate) return;\r\n\r\n        function updateValidationStatus(tryToTriggerMetaChange) {\r\n            formMeta.validating = !!validatingFieldCount;\r\n\r\n            // collect form warning/error\r\n            forEachField(formMeta.fields, true, f => {\r\n                if (!formMeta.error && f.error) {\r\n                    formMeta.error = f.error;\r\n                    formMeta.invalid = true;\r\n                    formMeta.valid = false;\r\n                }\r\n                if (!formMeta.warning && f.warning) {\r\n                    formMeta.warning = f.warning;\r\n                    return false;\r\n                }\r\n\r\n                if (formMeta.error && formMeta.warning) {\r\n                    return false;\r\n                }\r\n            });\r\n\r\n            if (tryToTriggerMetaChange && !validationCancelled) {\r\n                if (formMeta.validating) {\r\n                    onChange(\r\n                        {\r\n                            ...formMeta\r\n                        },\r\n                        \"meta\"\r\n                    );\r\n                } else {\r\n                    formValidationResolve({\r\n                        ...formMeta\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        onValidate({\r\n            data: formData,\r\n            meta: formMeta,\r\n            warning(error) {\r\n                return new FormMessage(error, \"warning\");\r\n            },\r\n            info(error) {\r\n                return new FormMessage(error, \"info\");\r\n            },\r\n            validate(field, error, messageType = \"error\") {\r\n                return new Promise(fieldValidationResolve => {\r\n                    if (error) {\r\n                        // extract error from warning\r\n                        if (error instanceof FormMessage) {\r\n                            messageType = error.type;\r\n                            error = error.data;\r\n                        }\r\n\r\n                        const fieldMeta = field\r\n                            ? view(pathToLens(field), formMeta.fields)\r\n                            : formMeta;\r\n\r\n                        //console.log(fieldMeta, field, error);\r\n\r\n                        if (error.then) {\r\n                            validatingFieldCount++;\r\n\r\n                            function done(asyncError) {\r\n                                if (asyncError instanceof FormMessage) {\r\n                                    messageType = asyncError.type;\r\n                                    asyncError = asyncError.data;\r\n                                }\r\n\r\n                                validatingFieldCount--;\r\n                                fieldMeta.validating = false;\r\n                                fieldMeta[messageType] = asyncError;\r\n                                fieldValidationResolve(!asyncError);\r\n                                updateValidationStatus(true);\r\n                            }\r\n\r\n                            error.then(() => done(), done);\r\n                        } else {\r\n                            fieldMeta[messageType] = error;\r\n                            fieldValidationResolve(false);\r\n                            updateValidationStatus();\r\n                        }\r\n                    } else {\r\n                        fieldValidationResolve(true);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        updateValidationStatus(true);\r\n    });\r\n}\r\n\r\n/**\r\n * handle form submitting\r\n */\r\nfunction formSubmitWrapper(\r\n    formData,\r\n    { onChange, onSubmit, onValidate, ...formMeta }\r\n) {\r\n    if (!onSubmit) return;\r\n\r\n    if (formData.validateOnSubmit) {\r\n        function handleMetaChange(newMeta) {\r\n            onChange(formData, newMeta, \"meta\");\r\n        }\r\n\r\n        validateForm({\r\n            data: formData,\r\n            meta: formMeta,\r\n            onChange: handleMetaChange,\r\n            onValidate\r\n        }).then(handleMetaChange);\r\n    } else {\r\n        onSubmit(formData, formMeta);\r\n    }\r\n}\r\n\r\n/**\r\n * handle change and validation\r\n */\r\nfunction formChangeWrapper(\r\n    initialData,\r\n    formData,\r\n    { onChange, onSubmit, onValidate, ...formMeta },\r\n    changeType\r\n) {\r\n    if (changeType === \"value\") {\r\n        if (!formMeta.validateOnSubmit) {\r\n            function handleMetaChange(newMeta) {\r\n                onChange(formData, newMeta, \"meta\");\r\n            }\r\n\r\n            validateForm({\r\n                data: formData,\r\n                meta: formMeta,\r\n                onChange: handleMetaChange,\r\n                onValidate\r\n            }).then(handleMetaChange);\r\n        }\r\n\r\n        if (!formMeta.initialData) {\r\n            formMeta.initialData = initialData;\r\n        }\r\n    }\r\n\r\n    onChange(formData, formMeta, changeType);\r\n}\r\n\r\nfunction forEachField(fields, deep, callback) {\r\n    let cancel = false;\r\n\r\n    function processField(field, name) {\r\n        if (field.type === \"field\") {\r\n            if (callback(field, name) === false) return false;\r\n            if (deep) {\r\n                // is field array\r\n                if (field.items) {\r\n                    cancel = field.items.some((sf, i) => processField(sf, i) === false);\r\n                }\r\n                // is sub form\r\n                if (field.fields) {\r\n                    cancel = forEachField(field.fields, true, callback) === false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    forEachObjIndexed((f, n) => {\r\n        if (cancel) return;\r\n        cancel = processField(f, n) === false;\r\n    }, fields);\r\n\r\n    return !cancel;\r\n}\r\n\r\nexport function fieldArray(options, fieldName, method, ...args) {\r\n    let { meta: formMeta, data: formData, onChange = noop } = options;\r\n    if (!method) {\r\n        // create an executor for field array\r\n        const executor = {};\r\n\r\n        fieldArrayMethods.forEach(\r\n            x =>\r\n                (executor[x] = function(...args) {\r\n                    return fieldArray(options, fieldName, x, ...args);\r\n                })\r\n        );\r\n        return executor;\r\n    }\r\n\r\n    const fieldLens = pathToLens(fieldName);\r\n    let value = view(fieldLens, formData);\r\n\r\n    let fieldMeta = view(fieldLens, formMeta.fields);\r\n    if (!fieldMeta) {\r\n        // mutate fields, dont fire meta change event to improve performance\r\n        formMeta.fields = set(\r\n            fieldLens,\r\n            (fieldMeta = {\r\n                type: \"field\"\r\n            }),\r\n            formMeta.fields\r\n        );\r\n    }\r\n\r\n    if (!(value instanceof Array)) {\r\n        value = value === null || value === undefined ? [] : [value];\r\n        if (!method) return value;\r\n    } else {\r\n        if (!method) return value;\r\n        value = [...value];\r\n    }\r\n\r\n    if (!fieldMeta.items) {\r\n        // create item meta\r\n        fieldMeta.items = value.map(() => ({\r\n            type: \"field\"\r\n        }));\r\n    }\r\n\r\n    // is render\r\n    if (method instanceof Function) {\r\n        return value.map((item, index) => {\r\n            function onMetaChange(subMeta) {\r\n                fieldMeta.items = [...fieldMeta.items];\r\n                fieldMeta.items[index] = subMeta;\r\n\r\n                onChange(formData, formMeta, \"meta\");\r\n            }\r\n\r\n            function onValueChange(subValue) {\r\n                const copyOfValue = [...value];\r\n                copyOfValue[index] = subValue;\r\n                formData = set(fieldLens, copyOfValue, formData);\r\n                fieldMeta.dirty = true;\r\n                formMeta.dirty = true;\r\n                onChange(formData, formMeta, \"value\");\r\n            }\r\n\r\n            return renderField({\r\n                name: index,\r\n                data: value,\r\n                render: method,\r\n                onMetaChange,\r\n                onValueChange,\r\n                meta: {\r\n                    ...fieldMeta.items[index],\r\n                    // sub form methods\r\n                    onSubmit(subData, subMeta) {\r\n                        // do nothing\r\n                    },\r\n                    onChange(subData, subMeta, changeType) {\r\n                        if (changeType === \"meta\") {\r\n                            onMetaChange(subMeta);\r\n                        } else if (changeType === \"value\") {\r\n                            onValueChange(subData);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    } else {\r\n        let metaItems = [...fieldMeta.items];\r\n\r\n        // support custom methods\r\n        switch (method) {\r\n            case \"removeAt\":\r\n                value.splice(args[0], 1);\r\n                metaItems.splice(args[0]);\r\n                break;\r\n            case \"remove\":\r\n                const indexesToRemove = [];\r\n                value = value.filter((x, i) => {\r\n                    if (x === args[0]) {\r\n                        indexesToRemove.push(i);\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                });\r\n                // remove metadata\r\n                while (indexesToRemove.length) {\r\n                    metaItems.splice(indexesToRemove.pop(), 1);\r\n                }\r\n                break;\r\n            case \"shift\":\r\n                metaItems.shift();\r\n                value.shift();\r\n                break;\r\n            case \"pop\":\r\n                metaItems.pop();\r\n                value.pop();\r\n                break;\r\n            case \"prepend\":\r\n            case \"unshift\":\r\n                metaItems.unshift(\r\n                    ...args.map(() => ({\r\n                        type: \"field\"\r\n                    }))\r\n                );\r\n                value.unshift(...args);\r\n                break;\r\n            case \"append\":\r\n            case \"push\":\r\n                metaItems.push(\r\n                    ...args.map(() => ({\r\n                        type: \"field\"\r\n                    }))\r\n                );\r\n                value.push(...args);\r\n                break;\r\n            case \"move\":\r\n            {\r\n                const [fromIndex, toIndex] = args;\r\n                if (fromIndex < 0 || fromIndex >= value.length) {\r\n                    throw new Error(\"fromIndex is not valid\");\r\n                }\r\n                if (toIndex < 0 || toIndex >= value.length) {\r\n                    throw new Error(\"toIndex is not valid\");\r\n                }\r\n\r\n                if (fromIndex === toIndex) {\r\n                    return;\r\n                }\r\n\r\n                // move down: insert first -> then remove\r\n                if (toIndex > fromIndex) {\r\n                    metaItems.splice(toIndex + 1, 0, metaItems[fromIndex]);\r\n                    metaItems.splice(fromIndex, 1);\r\n\r\n                    value.splice(toIndex + 1, 0, value[fromIndex]);\r\n                    value.splice(fromIndex, 1);\r\n                } else {\r\n                    // move up: remove first -> then insert\r\n                    metaItems.splice(toIndex, 0, metaItems.splice(fromIndex, 1)[0]);\r\n                    value.splice(toIndex, 0, value.splice(fromIndex, 1)[0]);\r\n                }\r\n            }\r\n                break;\r\n            case \"swap\":\r\n            {\r\n                const [sourceIndex, targetIndex] = args;\r\n                if (sourceIndex < 0 || sourceIndex >= value.length) {\r\n                    throw new Error(\"sourceIndex is not valid\");\r\n                }\r\n                if (targetIndex < 0 || targetIndex >= value.length) {\r\n                    throw new Error(\"targetIndex is not valid\");\r\n                }\r\n\r\n                if (sourceIndex === targetIndex) {\r\n                    return;\r\n                }\r\n\r\n                const tempMeta = metaItems[sourceIndex];\r\n                metaItems[sourceIndex] = metaItems[targetIndex];\r\n                metaItems[targetIndex] = tempMeta;\r\n\r\n                const tempItem = value[sourceIndex];\r\n                value[sourceIndex] = value[targetIndex];\r\n                value[targetIndex] = tempItem;\r\n            }\r\n\r\n                break;\r\n            case \"insert\":\r\n                let [index, ...newItems] = args;\r\n                index = index < 0 ? 0 : index > value.length ? value.length : index;\r\n                metaItems.splice(index, 0, ...newItems);\r\n                value.splice(index, 0, ...newItems);\r\n                break;\r\n            case \"removeAll\":\r\n                metaItems.splice(0, metaItems.length);\r\n                value.splice(0, value.length);\r\n                break;\r\n            case \"sort\":\r\n                // combine all meta/data to pair list\r\n                const pairs = value.map((x, i) => ({\r\n                    data: x,\r\n                    meta: metaItems[i]\r\n                }));\r\n                // suport sort by expression: prop:direction\r\n                const sortExpression =\r\n                    typeof args[0] === \"string\" ? args[0].split(\":\") : null;\r\n                // sort uses comparator, ascend by default\r\n                const propSelector = sortExpression\r\n                    ? prop(sortExpression[0])\r\n                    : args[0] || identity;\r\n                const inputComparator =\r\n                    sortExpression && sortExpression.length > 1\r\n                        ? sortExpression[1]\r\n                        : args[1];\r\n\r\n                const comparator =\r\n                    inputComparator === \"asc\"\r\n                        ? ascend\r\n                        : inputComparator === \"desc\" ? descend : inputComparator || ascend;\r\n                const sortedPairs = sort(\r\n                    comparator(compose(propSelector, prop(\"data\"))),\r\n                    pairs\r\n                );\r\n                // extract meta and data\r\n                sortedPairs.forEach((x, i) => {\r\n                    metaItems[i] = x.meta;\r\n                    value[i] = x.data;\r\n                });\r\n                break;\r\n            default:\r\n                throw new Error(`fieldArray does not support \"${method}\"`);\r\n        }\r\n\r\n        formData = set(fieldLens, value, formData);\r\n\r\n        formMeta.fields = set(\r\n            fieldLens,\r\n            (fieldMeta = {\r\n                ...fieldMeta,\r\n                items: metaItems\r\n            }),\r\n            formMeta.fields\r\n        );\r\n        formMeta.dirty = true;\r\n\r\n        onChange(formData, formMeta, \"value\");\r\n    }\r\n}\r\n"]}