{"version":3,"sources":["../index.js"],"names":["create","form","noop","cancellationToken","debounce","f","delay","timerId","clearTimeout","args","setTimeout","parsePath","path","toString","split","pathToLens","createCancellablePromise","promise","isCancellable","ct","cancellablePromise","then","Promise","reject","result","reason","cancel","value","abort","initialState","defState","storageOptions","autoSaveSubscription","autoSave","state","store","getState","localStorage","setItem","key","JSON","stringify","subscribeAutoSave","subscribe","serializedAppData","getItem","parse","defaultReducer","action","actionKey","payload","stateToCompare","v","k","customReducer","Date","getTime","dispatch","actionWrappers","$state","changes","arguments","length","type","dummyDispatch","Math","random","registerActions","parentKey","model","x","originalKey","originalKeyParts","originalActionName","options","Function","Array","actionName","name","actionPath","actionWrapper","currentOptions","dispatchQueue","dispatchStatus","single","lastResult","addToDispatchQueue","callback","push","trigger","dispatchData","types","forEach","i","actionResult","error","executing","success","fail","$async","__asyncOptions","$done","$fail","$success","$current","current","def","ex","asyncOptions","loading","asyncResult","Object","assign","undefined","with","actionLens","app","Provider","props","children","connect","Error","mapper","prefetch","prefetchArgsSelector","identity","reselect","isFetchResult","status","$fetch","connection","dispatchProps","ownProps","to","reducer","subscriber","actions","selector","createSelector","invoke","onChange","formChange","onSubmit","formSubmit","formMeta","data","formRender","fields","getFormMeta","validate","meta","validatingFieldCount","hasFieldError","validationCancelled","validating","invalid","valid","cancelValidation","onValidate","field","fieldMeta","done","e","formChangeWrapper","changeType","validateOnSubmit","formSubmitWrapper","preventDefault","fieldArray","fieldName","method","fieldLens","items","map","item","index","onMetaChange","subMeta","onValueChange","subValue","copyOfValue","dirty","renderField","render","subData","splice","indexesToRemove","filter","pop","shift","unshift","fieldRender","fieldView","fieldValue","onFocus","touched","focus","stopPropagation","target","onBlur"],"mappings":"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","file":"index.js","sourcesContent":["import React from \"react\";\r\nimport {connect, Provider} from \"react-redux\";\r\nimport {createStore, combineReducers} from \"redux\";\r\nimport {createSelector} from \"reselect\";\r\nimport {\r\n    forEachObjIndexed as each,\r\n    set,\r\n    view,\r\n    lensPath,\r\n    equals,\r\n    map,\r\n    identity,\r\n    contains\r\n} from \"ramda\";\r\n\r\nconst noop = () => {\r\n};\r\nconst cancellationToken = {};\r\n\r\nfunction debounce(f, delay = 0) {\r\n    let timerId;\r\n    return function (...args) {\r\n        clearTimeout(timerId);\r\n        timerId = setTimeout(f, delay, ...args);\r\n    };\r\n}\r\n\r\nfunction parsePath(path) {\r\n    return path.toString().split(/[.[\\]]/);\r\n}\r\n\r\n/**\r\n * create lens from path\r\n */\r\nfunction pathToLens(path) {\r\n    return lensPath(parsePath(path));\r\n}\r\n\r\nfunction createCancellablePromise(promise) {\r\n    if (promise.isCancellable) return promise;\r\n\r\n    let ct;\r\n\r\n    const cancellablePromise = promise.then(\r\n        result => {\r\n            if (ct) {\r\n                return Promise.reject(ct);\r\n            }\r\n            return result;\r\n        },\r\n        reason => {\r\n            return ct || reason;\r\n        }\r\n    );\r\n\r\n    cancellablePromise.cancel = function (value = cancellationToken) {\r\n        if (ct) return this;\r\n        //console.log('cancelled');\r\n        if (promise.abort) {\r\n            promise.abort();\r\n        }\r\n        if (promise.cancel) {\r\n            promise.cancel();\r\n        }\r\n        ct = value;\r\n        return this;\r\n    };\r\n\r\n    cancellablePromise.isCancellable = true;\r\n\r\n    return cancellablePromise;\r\n}\r\n\r\nexport function create(initialState = {}, defState = {}) {\r\n    let storageOptions = {};\r\n    let autoSaveSubscription;\r\n\r\n    function autoSave() {\r\n        const state = store.getState();\r\n        localStorage.setItem(storageOptions.key, JSON.stringify(state));\r\n    }\r\n\r\n    function subscribeAutoSave() {\r\n        if (autoSaveSubscription) {\r\n            autoSaveSubscription();\r\n            if (!storageOptions.key) {\r\n                return;\r\n            }\r\n        }\r\n        autoSaveSubscription = store.subscribe(\r\n            debounce(autoSave, storageOptions.debounce || 200)\r\n        );\r\n    }\r\n\r\n    if (typeof initialState === \"string\") {\r\n        storageOptions = {key: initialState};\r\n\r\n        const serializedAppData = localStorage.getItem(storageOptions.key);\r\n        if (serializedAppData) {\r\n            initialState = JSON.parse(serializedAppData) || defState;\r\n        } else {\r\n            initialState = defState;\r\n        }\r\n    }\r\n\r\n    function defaultReducer(state = initialState, action) {\r\n        // extract action info\r\n        const {[actionKey]: key, payload} = action;\r\n        if (key) {\r\n            // is merge action, merge state and payload\r\n            // need to improve this logic, avoid update call if state is not changed\r\n            if (key === \"@\") {\r\n                // extract properties to compare\r\n                const stateToCompare = map((v, k) => state[k], payload);\r\n                if (equals(stateToCompare, payload)) {\r\n                    return state;\r\n                }\r\n\r\n                return {\r\n                    ...state,\r\n                    ...payload\r\n                };\r\n            }\r\n\r\n            // if there is any change with this key/prop, clone current state and apply the changes\r\n            if (equals(view(pathToLens(key), state), payload)) return state;\r\n\r\n            //console.log(action);\r\n\r\n            return set(pathToLens(key), payload, state);\r\n        }\r\n\r\n        // call custom reducers if any\r\n        return customReducer ? customReducer(state, action) : state;\r\n    }\r\n\r\n    // create random action key\r\n    const actionKey = new Date().getTime().toString();\r\n    const store = createStore(defaultReducer);\r\n\r\n    subscribeAutoSave();\r\n\r\n    function dispatch(action) {\r\n        //console.log('[dispatch]', action);\r\n        store.dispatch(action);\r\n    }\r\n\r\n    let actionWrappers = {\r\n        /**\r\n         * get/update state\r\n         */\r\n        $state(changes) {\r\n            if (arguments.length < 1) return store.getState();\r\n            if (changes) {\r\n                dispatch({\r\n                    type: \"merge\",\r\n                    [actionKey]: \"@\",\r\n                    payload: changes\r\n                });\r\n            }\r\n        }\r\n    };\r\n\r\n    let customReducer = null;\r\n\r\n    function dummyDispatch() {\r\n        dispatch({\r\n            type: \"@dummy\",\r\n            [actionKey]: \"__dummy__\",\r\n            payload: Math.random() * new Date().getTime()\r\n        });\r\n    }\r\n\r\n    function registerActions(parentKey, model) {\r\n        each((x, k) => {\r\n            const originalKey = k;\r\n            const originalKeyParts = originalKey.split(\":\");\r\n            let originalActionName;\r\n            let options = {};\r\n\r\n            // supports named actionName:stateProp\r\n            if (originalKeyParts.length > 1) {\r\n                k = originalKeyParts[1];\r\n                originalActionName = originalKeyParts[0];\r\n            }\r\n\r\n            if (parentKey) {\r\n                k = parentKey + \".\" + k;\r\n            }\r\n\r\n            // action setting can be Function or Array\r\n            // prop: Function\r\n            // prop: [actionName, Function]\r\n            if (x instanceof Function || x instanceof Array) {\r\n                // try to get action name\r\n                let actionName = originalActionName || x.name || originalKey;\r\n\r\n                if (x instanceof Array) {\r\n                    options = x[1] || options;\r\n                    if (typeof options === \"string\") {\r\n                        options = {name: options};\r\n                    }\r\n                    actionName = options.name || actionName;\r\n\r\n                    x = x[0];\r\n                }\r\n\r\n                const actionPath = (parentKey ? parentKey + \".\" : \"\") + actionName;\r\n                // create action wrapper\r\n                const actionWrapper = (...args) => {\r\n                    const currentOptions = actionWrapper.options || options;\r\n                    const dispatchQueue = [];\r\n                    delete actionWrapper.options;\r\n\r\n                    if (currentOptions.dispatchStatus) {\r\n                        currentOptions.single = true;\r\n                    }\r\n\r\n                    // cancel prev executing\r\n                    if (\r\n                        currentOptions.single &&\r\n                        actionWrapper.lastResult &&\r\n                        actionWrapper.lastResult.cancel\r\n                    ) {\r\n                        actionWrapper.lastResult.cancel();\r\n                    }\r\n\r\n                    delete actionWrapper.lastResult;\r\n\r\n                    function addToDispatchQueue(type, callback) {\r\n                        dispatchQueue.push({type, callback});\r\n                    }\r\n\r\n                    function trigger(dispatchData, ...types) {\r\n                        dispatchData && dispatch(dispatchData);\r\n\r\n                        dispatchQueue.forEach(i => {\r\n                            if (contains(i.type, types)) {\r\n                                i.callback();\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    const dispatchStatus = !currentOptions.dispatchStatus\r\n                        ? noop\r\n                        : dummyDispatch;\r\n\r\n                    let actionResult;\r\n                    delete actionWrapper.error;\r\n                    actionWrapper.executing = true;\r\n                    actionWrapper.success = false;\r\n                    actionWrapper.fail = false;\r\n\r\n                    try {\r\n                        actionResult = x(...args);\r\n\r\n                        // is lazy call, (...args) => (getState, actions) => actionBody\r\n                        if (actionResult instanceof Function) {\r\n                            actionResult = actionResult({\r\n                                ...actionWrappers,\r\n                                $async(promise, options = {}) {\r\n                                    if (promise && promise.then) {\r\n                                        promise.__asyncOptions = options;\r\n                                    }\r\n                                    return promise;\r\n                                },\r\n                                $done: x => addToDispatchQueue(\"done\", x),\r\n                                $fail: x => addToDispatchQueue(\"fail\", x),\r\n                                $success: x => addToDispatchQueue(\"success\", x),\r\n                                // provide get current value\r\n                                $current: def => {\r\n                                    const state = store.getState();\r\n                                    const current = view(pathToLens(k), state);\r\n                                    if (typeof current === \"undefined\") return def;\r\n                                    return current;\r\n                                }\r\n                            });\r\n                        }\r\n                    } catch (ex) {\r\n                        actionWrapper.fail = true;\r\n                        actionWrapper.error = ex;\r\n                        throw ex;\r\n                    } finally {\r\n                        actionWrapper.executing = false;\r\n                    }\r\n\r\n                    // is then-able object\r\n                    if (actionResult && actionResult.then) {\r\n                        const asyncOptions = actionResult.__asyncOptions;\r\n\r\n                        actionWrapper.executing = true;\r\n\r\n                        actionWrapper.lastResult = actionResult = createCancellablePromise(\r\n                            actionResult\r\n                        );\r\n\r\n                        if (asyncOptions && \"loading\" in asyncOptions) {\r\n                            dispatch({\r\n                                type: actionPath,\r\n                                [actionKey]: k,\r\n                                payload: asyncOptions.loading\r\n                            });\r\n                        }\r\n\r\n                        dispatchStatus();\r\n\r\n                        // handle async action call\r\n                        actionResult.then(\r\n                            asyncResult => {\r\n                                //console.log('[success]');\r\n                                actionWrapper.success = true;\r\n                                actionWrapper.executing = false;\r\n\r\n                                trigger(\r\n                                    {\r\n                                        type: actionPath,\r\n                                        [actionKey]: k,\r\n                                        payload: asyncResult\r\n                                    },\r\n                                    \"success\",\r\n                                    \"done\"\r\n                                );\r\n\r\n                                // make sure state changed if payload is undefined\r\n                                if (typeof payload === \"undefined\") {\r\n                                    dispatchStatus();\r\n                                }\r\n                            },\r\n                            ex => {\r\n                                if (ex === cancellationToken) return;\r\n                                //console.log('[fail]');\r\n                                actionWrapper.executing = false;\r\n                                actionWrapper.fail = true;\r\n                                actionWrapper.error = ex;\r\n\r\n                                if (asyncOptions && \"fail\" in asyncOptions) {\r\n                                    dispatch({\r\n                                        type: actionPath,\r\n                                        [actionKey]: k,\r\n                                        payload: asyncOptions.fail\r\n                                    });\r\n                                }\r\n\r\n                                dispatchStatus();\r\n                                trigger(null, \"fail\", \"done\");\r\n                            }\r\n                        );\r\n                    } else {\r\n                        actionWrapper.success = true;\r\n\r\n                        // handle sync action call\r\n                        trigger(\r\n                            {\r\n                                type: actionPath,\r\n                                [actionKey]: k,\r\n                                payload: actionResult\r\n                            },\r\n                            \"done\"\r\n                        );\r\n                    }\r\n\r\n                    return actionResult;\r\n                };\r\n\r\n                Object.assign(actionWrapper, {\r\n                    success: undefined,\r\n                    fail: undefined,\r\n                    executing: false,\r\n                    with: options => (...args) => {\r\n                        actionWrapper.options = options;\r\n                        return actionWrapper(...args);\r\n                    }\r\n                });\r\n\r\n                const actionLens = pathToLens(actionPath);\r\n\r\n                actionWrappers = set(actionLens, actionWrapper, actionWrappers);\r\n\r\n                if (!view(actionLens, app)) {\r\n                    Object.assign(app, actionWrappers);\r\n                }\r\n            } else {\r\n                registerActions(k, x);\r\n            }\r\n        }, model);\r\n    }\r\n\r\n    const app = {\r\n        /**\r\n         * create provider\r\n         */\r\n        Provider: props => <Provider store={store}>{props.children}</Provider>,\r\n        autoSave(options = {key: \"appState\"}) {\r\n            if (typeof options === \"string\") {\r\n                options = {key: options};\r\n            }\r\n\r\n            storageOptions = options;\r\n\r\n            subscribeAutoSave();\r\n            return app;\r\n        },\r\n        /**\r\n         * connect component\r\n         * connect(mapper, component)\r\n         * connect(mapper, prefetch, component)\r\n         * connect(mapper, [argsSelector, prefetch], component)\r\n         */\r\n        connect(...args) {\r\n            if (args.length < 1) {\r\n                throw new Error(\"Argument count mismatch\");\r\n            }\r\n            let mapper, prefetch, prefetchArgsSelector;\r\n            if (args.length === 1) {\r\n                [mapper] = args;\r\n            } else if (args.length === 2) {\r\n                [mapper, prefetch] = args;\r\n            } else if (args.length === 3) {\r\n                [mapper, prefetchArgsSelector, prefetch] = args;\r\n            }\r\n\r\n            // prefetch enabled\r\n            if (prefetch) {\r\n                prefetch = createSelector(prefetch, identity);\r\n\r\n                if (prefetchArgsSelector) {\r\n                    prefetchArgsSelector = createSelector(prefetchArgsSelector, identity);\r\n                }\r\n            }\r\n\r\n            // create selector to memoize props\r\n            const reselect = createSelector(identity, props => {\r\n                if (prefetch) {\r\n                    let result = prefetchArgsSelector\r\n                        ? prefetch(prefetchArgsSelector(props))\r\n                        : prefetch();\r\n\r\n                    if (result) {\r\n                        if (!result.isFetchResult) {\r\n                            if (result.then) {\r\n                                // init fetching status\r\n                                result.isFetchResult = true;\r\n                                result.status = \"loading\";\r\n                                result.loading = true;\r\n\r\n                                // handle async fetching\r\n                                result.then(\r\n                                    x => {\r\n                                        result.success = true;\r\n                                        result.loading = false;\r\n                                        result.status = \"success\";\r\n                                        result.payload = x;\r\n                                        dummyDispatch();\r\n                                    },\r\n                                    x => {\r\n                                        result.fail = true;\r\n                                        result.loading = false;\r\n                                        result.status = \"fail\";\r\n                                        result.payload = x;\r\n                                        dummyDispatch();\r\n                                    }\r\n                                );\r\n                            } else {\r\n                                result = {\r\n                                    isFetchResult: true,\r\n                                    status: \"success\",\r\n                                    success: true,\r\n                                    payload: result\r\n                                };\r\n                            }\r\n                        } else {\r\n                            // do not touch\r\n                        }\r\n                    } else {\r\n                        result = {\r\n                            status: \"success\",\r\n                            success: true,\r\n                            payload: result\r\n                        };\r\n                    }\r\n\r\n                    // clone fetching result to make sure mergedProps changed\r\n                    if (result && result.then && (result.success || result.fail)) {\r\n                        result = {\r\n                            isFetchResult: true,\r\n                            fail: result.fail,\r\n                            success: result.success,\r\n                            status: result.status,\r\n                            payload: result.payload\r\n                        };\r\n                    }\r\n\r\n                    props.$fetch = result;\r\n                }\r\n                return props;\r\n            });\r\n            const connection = connect(\r\n                state => ({state}),\r\n                null,\r\n                ({state}, dispatchProps, ownProps) =>\r\n                    reselect(mapper(state, actionWrappers, ownProps)) || ownProps\r\n            );\r\n\r\n            // add shortcut 'to'\r\n            connection.to = connection;\r\n\r\n            return connection;\r\n        },\r\n        /**\r\n         * register single action\r\n         */\r\n        action(key, action, options) {\r\n            if (!(action instanceof Function)) {\r\n                options = action;\r\n                action = identity;\r\n            }\r\n\r\n            registerActions(null, set(pathToLens(key), [action, options], {}));\r\n            return app;\r\n        },\r\n        /**\r\n         * add custom reducers. This is helpful for 3rd lib which need reducer (Router, Log...)\r\n         */\r\n        reducer(value) {\r\n            customReducer =\r\n                value instanceof Function ? value : combineReducers(value);\r\n            return app;\r\n        },\r\n        /**\r\n         * dispatch custom action\r\n         */\r\n        dispatch(...args) {\r\n            dispatch(...args);\r\n            return app;\r\n        },\r\n        debounce,\r\n        /**\r\n         *\r\n         */\r\n        subscribe(subscriber) {\r\n            return store.subscribe((...args) =>\r\n                subscriber(store.getState(), ...args)\r\n            );\r\n        },\r\n        /**\r\n         * register multiple actions\r\n         */\r\n        actions(model) {\r\n            registerActions(null, model);\r\n            return app;\r\n        },\r\n        /**\r\n         * create new selector\r\n         */\r\n        selector(...args) {\r\n            return createSelector(...args);\r\n        },\r\n        /**\r\n         * get current state\r\n         */\r\n        getState() {\r\n            return store.getState();\r\n        },\r\n        /**\r\n         *\r\n         */\r\n        invoke(actionPath, ...args) {\r\n            //console.log('[test]', actionPath);\r\n            const action = view(pathToLens(actionPath), actionWrappers);\r\n            return action(...args);\r\n        }\r\n    };\r\n\r\n    return app;\r\n}\r\n\r\nexport function form({\r\n                         onChange: formChange = noop,\r\n                         onSubmit: formSubmit = noop,\r\n                         ...formMeta\r\n                     } = {},\r\n                     data,\r\n                     formRender) {\r\n    let {fields = {}} = formMeta;\r\n    const getFormMeta = () => ({...formMeta, fields});\r\n\r\n    function validate(data, meta) {\r\n        let validatingFieldCount = 0;\r\n        let hasFieldError = false;\r\n        let validationCancelled = false;\r\n\r\n        meta.validating = false;\r\n        meta.invalid = false;\r\n        meta.valid = true;\r\n\r\n        if (meta.cancelValidation) {\r\n            meta.cancelValidation();\r\n        }\r\n\r\n        meta.cancelValidation = function () {\r\n            validationCancelled = true;\r\n        };\r\n\r\n        // clear field validation\r\n        each(f => {\r\n            delete f.error;\r\n            f.validating = false;\r\n        }, meta.fields);\r\n\r\n        if (meta.onValidate) {\r\n            meta.onValidate({\r\n                data,\r\n                meta,\r\n                validate(field, error) {\r\n                    if (error) {\r\n                        const fieldMeta = view(pathToLens(field), meta.fields);\r\n                        if (error.then) {\r\n                            validatingFieldCount++;\r\n\r\n                            function done(e) {\r\n                                validatingFieldCount--;\r\n                                fieldMeta.validating = false;\r\n\r\n                                if (e) {\r\n                                    hasFieldError = true;\r\n                                    fieldMeta.error = e;\r\n                                }\r\n\r\n                                // is the last validation\r\n                                if (!validatingFieldCount) {\r\n                                    meta.validating = false;\r\n\r\n                                    if (hasFieldError) {\r\n                                        meta.invalid = true;\r\n                                        meta.valid = false;\r\n                                    }\r\n\r\n                                    if (!validationCancelled) {\r\n                                        formChange(data, meta, \"meta\");\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            error.then(done, done);\r\n                        } else {\r\n                            fieldMeta.error = error;\r\n                            hasFieldError = true;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        if (validatingFieldCount) {\r\n            meta.validating = true;\r\n        }\r\n\r\n        if (hasFieldError) {\r\n            meta.invalid = true;\r\n            meta.valid = false;\r\n        }\r\n    }\r\n\r\n    function formChangeWrapper(data, meta, changeType) {\r\n        if (changeType === \"value\" && !meta.validateOnSubmit) {\r\n            validate(data, meta);\r\n        }\r\n\r\n        formChange(data, meta, changeType);\r\n    }\r\n\r\n    function formSubmitWrapper(data, meta) {\r\n        if (meta.validateOnSubmit) {\r\n            validate(data, meta);\r\n        }\r\n        formSubmit(data, meta);\r\n    }\r\n\r\n    return formRender({\r\n        props: {\r\n            onSubmit(e) {\r\n                if (e && e.preventDefault) {\r\n                    e.preventDefault();\r\n                }\r\n                formSubmitWrapper(data, getFormMeta());\r\n            }\r\n        },\r\n\r\n        fieldArray(fieldName, method, ...args) {\r\n            const fieldLens = pathToLens(fieldName);\r\n            let value = view(fieldLens, data);\r\n\r\n            let fieldMeta = view(fieldLens, fields);\r\n            if (!fieldMeta) {\r\n                fields = set(fieldLens, (fieldMeta = {}), fields);\r\n            }\r\n\r\n            if (!(value instanceof Array)) {\r\n                value = value === null || value === undefined ? [] : [value];\r\n                if (!method) return value;\r\n            } else {\r\n                if (!method) return value;\r\n                value = [...value];\r\n            }\r\n\r\n            if (!fieldMeta.items) {\r\n                // create item meta\r\n                fieldMeta.items = value.map(() => ({}));\r\n            }\r\n\r\n            // is render\r\n            if (method instanceof Function) {\r\n                return value.map((item, index) => {\r\n                    function onMetaChange(subMeta) {\r\n                        fieldMeta.items[index] = subMeta;\r\n                        formChangeWrapper(data, getFormMeta(), \"meta\");\r\n                    }\r\n\r\n                    function onValueChange(subValue) {\r\n                        const copyOfValue = [...value];\r\n                        copyOfValue[index] = subValue;\r\n                        data = set(fieldLens, copyOfValue, data);\r\n                        fieldMeta.dirty = true;\r\n                        formMeta.dirty = true;\r\n                        formChangeWrapper(data, getFormMeta(), \"value\");\r\n                    }\r\n\r\n                    return renderField({\r\n                        name: index,\r\n                        data: value,\r\n                        render: method,\r\n                        onMetaChange,\r\n                        onValueChange,\r\n                        meta: {\r\n                            ...fieldMeta.items[index],\r\n                            // sub form method\r\n                            onSubmit(subData, subMeta) {\r\n                                // do nothing\r\n                            },\r\n                            onChange(subData, subMeta, changeType) {\r\n                                if (changeType === \"meta\") {\r\n                                    onMetaChange(subMeta);\r\n                                } else if (changeType === \"value\") {\r\n                                    onValueChange(subData);\r\n                                }\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n            } else {\r\n                // support custom methods\r\n                switch (method) {\r\n                    case \"removeAt\":\r\n                        value.splice(args[0], 1);\r\n                        fieldMeta.items.splice(args[0]);\r\n                        break;\r\n                    case \"remove\":\r\n                        const indexesToRemove = [];\r\n                        value = value.filter((x, i) => {\r\n                            if (x === args[0]) {\r\n                                indexesToRemove.push(i);\r\n                                return false;\r\n                            }\r\n                            return true;\r\n                        });\r\n                        // remove metadata\r\n                        while (indexesToRemove.length) {\r\n                            fieldMeta.items.splice(indexesToRemove.pop(), 1);\r\n                        }\r\n                        break;\r\n                    case \"shift\":\r\n                        fieldMeta.items.shift();\r\n                        value.shift();\r\n                        break;\r\n                    case \"pop\":\r\n                        fieldMeta.items.pop();\r\n                        value.pop();\r\n                        break;\r\n                    case \"unshift\":\r\n                        fieldMeta.items.unshift(...args.map(() => ({})));\r\n                        value.unshift(...args);\r\n                        break;\r\n                    case \"push\":\r\n                        fieldMeta.items.push(...args.map(() => ({})));\r\n                        value.push(...args);\r\n                        break;\r\n                    default:\r\n                        // call default method\r\n                        value[method](...args);\r\n                        break;\r\n                }\r\n\r\n                data = set(fieldLens, value, data);\r\n                formChange(data, getFormMeta(), \"value\");\r\n            }\r\n        },\r\n\r\n        field: function field(fieldName, fieldRender) {\r\n            const fieldLens = pathToLens(fieldName);\r\n            const fieldView = view(fieldLens);\r\n            let fieldMeta = fieldView(fields);\r\n            if (!fieldMeta) {\r\n                fields = set(fieldLens, (fieldMeta = {}), fields);\r\n            }\r\n\r\n            return renderField({\r\n                name: fieldName,\r\n                meta: fieldMeta,\r\n                data: data,\r\n                render: fieldRender,\r\n                onMetaChange() {\r\n                    formChangeWrapper(data, getFormMeta(), \"meta\");\r\n                },\r\n                onValueChange(value) {\r\n                    data = set(fieldLens, value, data);\r\n                    fieldMeta.dirty = true;\r\n                    formMeta.dirty = true;\r\n                    formChangeWrapper(data, getFormMeta(), \"value\");\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nfunction renderField({\r\n                         name,\r\n                         meta,\r\n                         data,\r\n                         render,\r\n                         onMetaChange,\r\n                         onValueChange\r\n                     }) {\r\n    const fieldView = view(pathToLens(name));\r\n    const fieldValue = fieldView(data);\r\n    return render({\r\n        name,\r\n        props: {\r\n            onFocus() {\r\n                meta.touched = true;\r\n                meta.focus = true;\r\n                onMetaChange(meta);\r\n            },\r\n            onChange(e) {\r\n                const value =\r\n                    e && e.stopPropagation instanceof Function ? e.target.value : e;\r\n\r\n                onValueChange(value);\r\n            },\r\n            onBlur() {\r\n                meta.focus = false;\r\n                onMetaChange(meta);\r\n            },\r\n            value: fieldValue\r\n        },\r\n        meta,\r\n        value: fieldValue\r\n    });\r\n}\r\n"]}