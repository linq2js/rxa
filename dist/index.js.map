{"version":3,"sources":["../index.js"],"names":["create","noop","cancellationToken","debounce","f","delay","timerId","clearTimeout","args","setTimeout","parsePath","path","split","pathToLens","createCancellablePromise","promise","isCancellable","ct","cancellablePromise","then","result","Promise","reject","reason","cancel","value","abort","initialState","actionKey","Date","getTime","toString","store","state","action","key","payload","stateToCompare","v","k","customReducers","dispatch","actionWrappers","$","changes","type","dummyDispatch","Math","random","registerActions","parentKey","model","x","originalKey","options","Function","Array","name","actionPath","actionWrapper","currentOptions","single","lastResult","dispatchStatus","actionResult","error","executing","success","fail","getState","ex","asyncResult","Object","assign","undefined","with","app","Provider","props","children","connect","length","Error","mapper","prefetch","prefetchArgsSelector","identity","reselect","fetchResult","isFetchResult","status","loading","$fetch","dispatchProps","ownProps","reducers","subscribe","subscriber","actions","selector","createSelector","test"],"mappings":"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","file":"index.js","sourcesContent":["import React from 'react';\r\nimport { connect, Provider } from 'react-redux';\r\nimport { createStore, combineReducers } from 'redux';\r\nimport { createSelector } from 'reselect';\r\nimport { forEachObjIndexed as each, set, view, lensPath, equals, map, identity } from 'ramda';\r\n\r\nconst noop = () => {};\r\nconst cancellationToken = {};\r\n\r\nfunction debounce(f, delay = 0) {\r\n    let timerId;\r\n    return function(...args) {\r\n        clearTimeout(timerId);\r\n        timerId = setTimeout(f, delay, ...args);\r\n    };\r\n}\r\n\r\nfunction parsePath(path) {\r\n    return path.split(/[.[\\]]/);\r\n}\r\n\r\n/**\r\n * create lens from path\r\n */\r\nfunction pathToLens(path) {\r\n    return lensPath(parsePath(path));\r\n}\r\n\r\nfunction createCancellablePromise(promise) {\r\n    if (promise.isCancellable) return promise;\r\n\r\n    let ct;\r\n\r\n    const cancellablePromise = promise.then(\r\n        (result) => {\r\n            if (ct) {\r\n                return Promise.reject(ct);\r\n            }\r\n            return result;\r\n        },\r\n        (reason) => {\r\n            return ct || reason;\r\n        }\r\n    );\r\n\r\n    cancellablePromise.cancel = function(value = cancellationToken) {\r\n        if (ct) return this;\r\n        //console.log('cancelled');\r\n        if (promise.abort) {\r\n            promise.abort();\r\n        }\r\n        if (promise.cancel) {\r\n            promise.cancel();\r\n        }\r\n        ct = value;\r\n        return this;\r\n    };\r\n\r\n    cancellablePromise.isCancellable = true;\r\n\r\n    return cancellablePromise;\r\n}\r\n\r\nexport function create(initialState = {}) {\r\n    // create random action key\r\n    const actionKey = new Date().getTime().toString();\r\n    const store = createStore((state = initialState, action) => {\r\n        // extract action info\r\n        const { [actionKey]: key, payload } = action;\r\n        if (key) {\r\n            // is merge action, merge state and payload\r\n            // need to improve this logic, avoid update call if state is not changed\r\n            if (key === '@') {\r\n                // extract properties to compare\r\n                const stateToCompare = map((v, k) => state[k], payload);\r\n                if (equals(stateToCompare, payload)) {\r\n                    return state;\r\n                }\r\n\r\n                return {\r\n                    ...state,\r\n                    ...payload,\r\n                };\r\n            }\r\n\r\n            // if there is any change with this key/prop, clone current state and apply the changes\r\n            if (equals(view(pathToLens(key), state), payload)) return state;\r\n\r\n            //console.log(action);\r\n\r\n            return set(pathToLens(key), payload, state);\r\n        }\r\n\r\n        // call custom reducers if any\r\n        return customReducers ? customReducers(state, action) : state;\r\n    });\r\n\r\n    function dispatch(action) {\r\n        //console.log('[dispatch]', action);\r\n        store.dispatch(action);\r\n    }\r\n\r\n    let actionWrappers = {\r\n        /**\r\n         * update state\r\n         */\r\n        $(changes = {}) {\r\n            dispatch({\r\n                type: 'merge',\r\n                [actionKey]: '@',\r\n                payload: changes,\r\n            });\r\n        },\r\n    };\r\n\r\n    let customReducers = null;\r\n\r\n    function dummyDispatch() {\r\n        dispatch({\r\n            type: '@dummy',\r\n            [actionKey]: '__dummy__',\r\n            payload: Math.random() * new Date().getTime(),\r\n        });\r\n    }\r\n\r\n    function registerActions(parentKey, model) {\r\n        each((x, k) => {\r\n            const originalKey = k;\r\n            let options = {};\r\n            if (parentKey) {\r\n                k = parentKey + '.' + k;\r\n            }\r\n\r\n            // action setting can be Function or Array\r\n            // prop: Function\r\n            // prop: [actionName, Function]\r\n            if (x instanceof Function || x instanceof Array) {\r\n                let name = x.name || originalKey;\r\n\r\n                if (x instanceof Array) {\r\n                    options = x[1] || options;\r\n                    if (typeof options === 'string') {\r\n                        options = { name: options };\r\n                    }\r\n                    name = options.name || name;\r\n\r\n                    x = x[0];\r\n                }\r\n\r\n                const actionPath = (parentKey ? parentKey + '.' : '') + name;\r\n                // create action wrapper\r\n                const actionWrapper = (...args) => {\r\n                    const currentOptions = actionWrapper.options || options;\r\n                    delete actionWrapper.options;\r\n\r\n                    // cancel prev executing\r\n                    if (currentOptions.single && actionWrapper.lastResult && actionWrapper.lastResult.cancel) {\r\n                        actionWrapper.lastResult.cancel();\r\n                    }\r\n\r\n                    delete actionWrapper.lastResult;\r\n\r\n                    const dispatchStatus = !currentOptions.dispatchStatus ? noop : dummyDispatch;\r\n\r\n                    let actionResult;\r\n                    delete actionWrapper.error;\r\n                    actionWrapper.executing = true;\r\n                    actionWrapper.success = false;\r\n                    actionWrapper.fail = false;\r\n\r\n                    try {\r\n                        actionResult = x(...args);\r\n\r\n                        // is lazy call, (...args) => (getState, actions) => actionBody\r\n                        if (actionResult instanceof Function) {\r\n                            actionResult = actionResult(store.getState, actionWrappers);\r\n                        }\r\n                    } catch (ex) {\r\n                        actionWrapper.fail = true;\r\n                        actionWrapper.error = ex;\r\n                        throw ex;\r\n                    } finally {\r\n                        actionWrapper.executing = false;\r\n                    }\r\n\r\n                    // is then-able object\r\n                    if (actionResult && actionResult.then) {\r\n                        actionWrapper.executing = true;\r\n\r\n                        actionWrapper.lastResult = actionResult = createCancellablePromise(actionResult);\r\n\r\n                        dispatchStatus();\r\n\r\n                        // handle async action call\r\n                        actionResult.then(\r\n                            (asyncResult) => {\r\n                                //console.log('[success]');\r\n                                actionWrapper.success = true;\r\n                                actionWrapper.executing = false;\r\n\r\n                                dispatch({\r\n                                    type: actionPath,\r\n                                    [actionKey]: k,\r\n                                    payload: asyncResult,\r\n                                });\r\n\r\n                                // make sure state changed if payload is undefined\r\n                                if (typeof payload === 'undefined') {\r\n                                    dispatchStatus();\r\n                                }\r\n                            },\r\n                            (ex) => {\r\n                                if (ex === cancellationToken) return;\r\n                                //console.log('[fail]');\r\n                                actionWrapper.executing = false;\r\n                                actionWrapper.fail = true;\r\n                                actionWrapper.error = ex;\r\n                                dispatchStatus();\r\n                            }\r\n                        );\r\n                    } else {\r\n                        actionWrapper.success = true;\r\n\r\n                        // handle sync action call\r\n                        dispatch({\r\n                            type: actionPath,\r\n                            [actionKey]: k,\r\n                            payload: actionResult,\r\n                        });\r\n                    }\r\n\r\n                    return actionResult;\r\n                };\r\n\r\n                Object.assign(actionWrapper, {\r\n                    success: undefined,\r\n                    fail: undefined,\r\n                    executing: false,\r\n                    with: (options) => (...args) => {\r\n                        actionWrapper.options = options;\r\n                        return actionWrapper(...args);\r\n                    },\r\n                });\r\n\r\n                actionWrappers = set(pathToLens(actionPath), actionWrapper, actionWrappers);\r\n            } else {\r\n                registerActions(k, x);\r\n            }\r\n        }, model);\r\n    }\r\n\r\n    const app = {\r\n        /**\r\n         * create provider\r\n         */\r\n        Provider: (props) => <Provider store={store}>{props.children}</Provider>,\r\n        /**\r\n         * connect component\r\n         * connect(mapper, component)\r\n         * connect(mapper, prefetch, component)\r\n         * connect(mapper, [argsSelector, prefetch], component)\r\n         */\r\n        connect(...args) {\r\n            if (args.length < 1) {\r\n                throw new Error('Argument count mismatch');\r\n            }\r\n            let mapper, prefetch, prefetchArgsSelector;\r\n            if (args.length === 1) {\r\n                [mapper] = args;\r\n            } else if (args.length === 2) {\r\n                [mapper, prefetch] = args;\r\n            } else if (args.length === 3) {\r\n                [mapper, prefetch, prefetchArgsSelector] = args;\r\n            }\r\n\r\n            // prefetch enabled\r\n            if (prefetch) {\r\n                // support prefetch args selector\r\n                if (prefetch instanceof Array) {\r\n                    [prefetchArgsSelector, prefetch] = prefetch;\r\n                }\r\n\r\n                prefetch = createSelector(prefetch, identity);\r\n\r\n                if (prefetchArgsSelector) {\r\n                    prefetchArgsSelector = createSelector(prefetchArgsSelector, identity);\r\n                }\r\n            }\r\n\r\n            // create selector to memoize props\r\n            const reselect = createSelector((props) => {\r\n                if (prefetch) {\r\n                    let fetchResult = prefetchArgsSelector ? prefetch(prefetchArgsSelector(props)) : prefetch();\r\n\r\n                    if (fetchResult) {\r\n                        if (!fetchResult.isFetchResult) {\r\n                            if (fetchResult.then) {\r\n                                // init fetching status\r\n                                fetchResult.isFetchResult = true;\r\n                                fetchResult.status = 'loading';\r\n                                fetchResult.loading = true;\r\n\r\n                                // handle async fetching\r\n                                fetchResult.then(\r\n                                    (x) => {\r\n                                        fetchResult.success = true;\r\n                                        fetchResult.loading = false;\r\n                                        fetchResult.status = 'success';\r\n                                        fetchResult.payload = x;\r\n                                        dummyDispatch();\r\n                                    },\r\n                                    (x) => {\r\n                                        fetchResult.fail = true;\r\n                                        fetchResult.loading = false;\r\n                                        fetchResult.status = 'fail';\r\n                                        fetchResult.payload = x;\r\n                                        dummyDispatch();\r\n                                    }\r\n                                );\r\n                            } else {\r\n                                fetchResult = {\r\n                                    isFetchResult: true,\r\n                                    status: 'success',\r\n                                    success: true,\r\n                                    payload: fetchResult,\r\n                                };\r\n                            }\r\n                        } else {\r\n                            // do not touch\r\n                        }\r\n                    } else {\r\n                        fetchResult = {\r\n                            status: 'success',\r\n                            success: true,\r\n                            payload: fetchResult,\r\n                        };\r\n                    }\r\n\r\n                    props.$fetch = fetchResult;\r\n                }\r\n                return props;\r\n            }, identity);\r\n            return connect(\r\n                (state) => ({ state }),\r\n                null,\r\n                ({ state }, dispatchProps, ownProps) => reselect(mapper(state, actionWrappers, ownProps)) || ownProps\r\n            );\r\n        },\r\n        /**\r\n         * register single action\r\n         */\r\n        action(key, action, options) {\r\n            registerActions(null, set(pathToLens(key), [action, options], {}));\r\n            return app;\r\n        },\r\n        /**\r\n         * add custom reducers. This is helpful for 3rd lib which need reducer (Router, Log...)\r\n         */\r\n        reducers(value) {\r\n            customReducers = combineReducers(value);\r\n            return app;\r\n        },\r\n        /**\r\n         * dispatch custom action\r\n         */\r\n        dispatch(...args) {\r\n            dispatch(...args);\r\n            return app;\r\n        },\r\n        debounce,\r\n        /**\r\n         *\r\n         */\r\n        subscribe(subscriber) {\r\n            return store.subscribe((...args) => subscriber(store.getState(), ...args));\r\n        },\r\n        /**\r\n         * register multiple actions\r\n         */\r\n        actions(model) {\r\n            registerActions(null, model);\r\n            return app;\r\n        },\r\n        /**\r\n         * create new selector\r\n         */\r\n        selector(...args) {\r\n            return createSelector(...args);\r\n        },\r\n        /**\r\n         * get current state\r\n         */\r\n        getState() {\r\n            return store.getState();\r\n        },\r\n        /**\r\n         * run test for specific action\r\n         */\r\n        test(actionPath, ...args) {\r\n            //console.log('[test]', actionPath);\r\n            const action = view(pathToLens(actionPath), actionWrappers);\r\n            return action(...args);\r\n        },\r\n    };\r\n\r\n    return app;\r\n}"]}