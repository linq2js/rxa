{"version":3,"sources":["../index.js"],"names":["create","noop","cancellationToken","debounce","f","delay","timerId","clearTimeout","args","setTimeout","parsePath","path","split","pathToLens","createCancellablePromise","promise","isCancellable","ct","cancellablePromise","then","result","Promise","reject","reason","cancel","value","abort","initialState","defState","storageOptions","autoSaveSubscription","autoSave","state","store","getState","localStorage","setItem","key","JSON","stringify","subscribeAutoSave","subscribe","serializedAppData","getItem","parse","defaultReducer","action","actionKey","payload","stateToCompare","v","k","customReducer","Date","getTime","toString","dispatch","actionWrappers","$","changes","type","dummyDispatch","Math","random","registerActions","parentKey","model","x","originalKey","options","Function","Array","name","actionPath","actionWrapper","currentOptions","single","lastResult","dispatchStatus","actionResult","error","executing","success","fail","ex","asyncResult","Object","assign","undefined","with","app","Provider","props","children","connect","length","Error","mapper","prefetch","prefetchArgsSelector","identity","reselect","isFetchResult","status","loading","$fetch","dispatchProps","ownProps","reducer","subscriber","actions","selector","createSelector","test"],"mappings":"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","file":"index.js","sourcesContent":["import React from 'react';\r\nimport {connect, Provider} from 'react-redux';\r\nimport {createStore, combineReducers} from 'redux';\r\nimport {createSelector} from 'reselect';\r\nimport {forEachObjIndexed as each, set, view, lensPath, equals, map, identity} from 'ramda';\r\n\r\nconst noop = () => {\r\n};\r\nconst cancellationToken = {};\r\n\r\nfunction debounce(f, delay = 0) {\r\n    let timerId;\r\n    return function (...args) {\r\n        clearTimeout(timerId);\r\n        timerId = setTimeout(f, delay, ...args);\r\n    };\r\n}\r\n\r\nfunction parsePath(path) {\r\n    return path.split(/[.[\\]]/);\r\n}\r\n\r\n/**\r\n * create lens from path\r\n */\r\nfunction pathToLens(path) {\r\n    return lensPath(parsePath(path));\r\n}\r\n\r\nfunction createCancellablePromise(promise) {\r\n    if (promise.isCancellable) return promise;\r\n\r\n    let ct;\r\n\r\n    const cancellablePromise = promise.then(\r\n        (result) => {\r\n            if (ct) {\r\n                return Promise.reject(ct);\r\n            }\r\n            return result;\r\n        },\r\n        (reason) => {\r\n            return ct || reason;\r\n        }\r\n    );\r\n\r\n    cancellablePromise.cancel = function (value = cancellationToken) {\r\n        if (ct) return this;\r\n        //console.log('cancelled');\r\n        if (promise.abort) {\r\n            promise.abort();\r\n        }\r\n        if (promise.cancel) {\r\n            promise.cancel();\r\n        }\r\n        ct = value;\r\n        return this;\r\n    };\r\n\r\n    cancellablePromise.isCancellable = true;\r\n\r\n    return cancellablePromise;\r\n}\r\n\r\nexport function create(initialState = {}, defState = {}) {\r\n    let storageOptions = {};\r\n    let autoSaveSubscription;\r\n\r\n    function autoSave() {\r\n        const state = store.getState();\r\n        localStorage.setItem(storageOptions.key, JSON.stringify(state));\r\n    }\r\n\r\n    function subscribeAutoSave() {\r\n        if (autoSaveSubscription) {\r\n            autoSaveSubscription();\r\n            if (!storageOptions.key) {\r\n                return;\r\n            }\r\n        }\r\n        autoSaveSubscription = store.subscribe(debounce(autoSave, storageOptions.debounce || 200));\r\n    }\r\n\r\n    if (typeof initialState === 'string') {\r\n        storageOptions = {key: initialState};\r\n\r\n        const serializedAppData = localStorage.getItem(storageOptions.key);\r\n        if (serializedAppData) {\r\n            initialState = JSON.parse(serializedAppData) || defState;\r\n        }\r\n        else {\r\n            initialState = defState;\r\n        }\r\n    }\r\n\r\n    function defaultReducer(state = initialState, action) {\r\n        // extract action info\r\n        const {[actionKey]: key, payload} = action;\r\n        if (key) {\r\n            // is merge action, merge state and payload\r\n            // need to improve this logic, avoid update call if state is not changed\r\n            if (key === '@') {\r\n                // extract properties to compare\r\n                const stateToCompare = map((v, k) => state[k], payload);\r\n                if (equals(stateToCompare, payload)) {\r\n                    return state;\r\n                }\r\n\r\n                return {\r\n                    ...state,\r\n                    ...payload,\r\n                };\r\n            }\r\n\r\n            // if there is any change with this key/prop, clone current state and apply the changes\r\n            if (equals(view(pathToLens(key), state), payload)) return state;\r\n\r\n            //console.log(action);\r\n\r\n            return set(pathToLens(key), payload, state);\r\n        }\r\n\r\n        // call custom reducers if any\r\n        return customReducer ? customReducer(state, action) : state;\r\n    }\r\n\r\n    // create random action key\r\n    const actionKey = new Date().getTime().toString();\r\n    const store = createStore(defaultReducer);\r\n\r\n    subscribeAutoSave();\r\n\r\n\r\n    function dispatch(action) {\r\n        //console.log('[dispatch]', action);\r\n        store.dispatch(action);\r\n    }\r\n\r\n    let actionWrappers = {\r\n        /**\r\n         * update state\r\n         */\r\n        $(changes = {}) {\r\n            dispatch({\r\n                type: 'merge',\r\n                [actionKey]: '@',\r\n                payload: changes,\r\n            });\r\n        },\r\n    };\r\n\r\n    let customReducer = null;\r\n\r\n    function dummyDispatch() {\r\n        dispatch({\r\n            type: '@dummy',\r\n            [actionKey]: '__dummy__',\r\n            payload: Math.random() * new Date().getTime(),\r\n        });\r\n    }\r\n\r\n    function registerActions(parentKey, model) {\r\n        each((x, k) => {\r\n            const originalKey = k;\r\n            let options = {};\r\n            if (parentKey) {\r\n                k = parentKey + '.' + k;\r\n            }\r\n\r\n            // action setting can be Function or Array\r\n            // prop: Function\r\n            // prop: [actionName, Function]\r\n            if (x instanceof Function || x instanceof Array) {\r\n                let name = x.name || originalKey;\r\n\r\n                if (x instanceof Array) {\r\n                    options = x[1] || options;\r\n                    if (typeof options === 'string') {\r\n                        options = {name: options};\r\n                    }\r\n                    name = options.name || name;\r\n\r\n                    x = x[0];\r\n                }\r\n\r\n                const actionPath = (parentKey ? parentKey + '.' : '') + name;\r\n                // create action wrapper\r\n                const actionWrapper = (...args) => {\r\n                    const currentOptions = actionWrapper.options || options;\r\n                    delete actionWrapper.options;\r\n\r\n                    // cancel prev executing\r\n                    if (currentOptions.single && actionWrapper.lastResult && actionWrapper.lastResult.cancel) {\r\n                        actionWrapper.lastResult.cancel();\r\n                    }\r\n\r\n                    delete actionWrapper.lastResult;\r\n\r\n                    const dispatchStatus = !currentOptions.dispatchStatus ? noop : dummyDispatch;\r\n\r\n                    let actionResult;\r\n                    delete actionWrapper.error;\r\n                    actionWrapper.executing = true;\r\n                    actionWrapper.success = false;\r\n                    actionWrapper.fail = false;\r\n\r\n                    try {\r\n                        actionResult = x(...args);\r\n\r\n                        // is lazy call, (...args) => (getState, actions) => actionBody\r\n                        if (actionResult instanceof Function) {\r\n                            actionResult = actionResult(store.getState, actionWrappers);\r\n                        }\r\n                    } catch (ex) {\r\n                        actionWrapper.fail = true;\r\n                        actionWrapper.error = ex;\r\n                        throw ex;\r\n                    } finally {\r\n                        actionWrapper.executing = false;\r\n                    }\r\n\r\n                    // is then-able object\r\n                    if (actionResult && actionResult.then) {\r\n                        actionWrapper.executing = true;\r\n\r\n                        actionWrapper.lastResult = actionResult = createCancellablePromise(actionResult);\r\n\r\n                        dispatchStatus();\r\n\r\n                        // handle async action call\r\n                        actionResult.then(\r\n                            (asyncResult) => {\r\n                                //console.log('[success]');\r\n                                actionWrapper.success = true;\r\n                                actionWrapper.executing = false;\r\n\r\n                                dispatch({\r\n                                    type: actionPath,\r\n                                    [actionKey]: k,\r\n                                    payload: asyncResult,\r\n                                });\r\n\r\n                                // make sure state changed if payload is undefined\r\n                                if (typeof payload === 'undefined') {\r\n                                    dispatchStatus();\r\n                                }\r\n                            },\r\n                            (ex) => {\r\n                                if (ex === cancellationToken) return;\r\n                                //console.log('[fail]');\r\n                                actionWrapper.executing = false;\r\n                                actionWrapper.fail = true;\r\n                                actionWrapper.error = ex;\r\n                                dispatchStatus();\r\n                            }\r\n                        );\r\n                    } else {\r\n                        actionWrapper.success = true;\r\n\r\n                        // handle sync action call\r\n                        dispatch({\r\n                            type: actionPath,\r\n                            [actionKey]: k,\r\n                            payload: actionResult,\r\n                        });\r\n                    }\r\n\r\n                    return actionResult;\r\n                };\r\n\r\n                Object.assign(actionWrapper, {\r\n                    success: undefined,\r\n                    fail: undefined,\r\n                    executing: false,\r\n                    with: (options) => (...args) => {\r\n                        actionWrapper.options = options;\r\n                        return actionWrapper(...args);\r\n                    },\r\n                });\r\n\r\n                actionWrappers = set(pathToLens(actionPath), actionWrapper, actionWrappers);\r\n            } else {\r\n                registerActions(k, x);\r\n            }\r\n        }, model);\r\n    }\r\n\r\n\r\n    const app = {\r\n        /**\r\n         * create provider\r\n         */\r\n        Provider: (props) => <Provider store={store}>{props.children}</Provider>,\r\n        autoSave(options = {}) {\r\n            if (typeof options === 'string') {\r\n                options = {key: options};\r\n            }\r\n\r\n            storageOptions = options;\r\n\r\n            subscribeAutoSave();\r\n            return app;\r\n        },\r\n        /**\r\n         * connect component\r\n         * connect(mapper, component)\r\n         * connect(mapper, prefetch, component)\r\n         * connect(mapper, [argsSelector, prefetch], component)\r\n         */\r\n        connect(...args) {\r\n            if (args.length < 1) {\r\n                throw new Error('Argument count mismatch');\r\n            }\r\n            let mapper, prefetch, prefetchArgsSelector;\r\n            if (args.length === 1) {\r\n                [mapper] = args;\r\n            } else if (args.length === 2) {\r\n                [mapper, prefetch] = args;\r\n            } else if (args.length === 3) {\r\n                [mapper, prefetchArgsSelector, prefetch] = args;\r\n            }\r\n\r\n            // prefetch enabled\r\n            if (prefetch) {\r\n                prefetch = createSelector(prefetch, identity);\r\n\r\n                if (prefetchArgsSelector) {\r\n                    prefetchArgsSelector = createSelector(prefetchArgsSelector, identity);\r\n                }\r\n            }\r\n\r\n            // create selector to memoize props\r\n            const reselect = createSelector(identity, (props) => {\r\n                if (prefetch) {\r\n                    let result = prefetchArgsSelector ? prefetch(prefetchArgsSelector(props)) : prefetch();\r\n\r\n                    if (result) {\r\n                        if (!result.isFetchResult) {\r\n                            if (result.then) {\r\n                                // init fetching status\r\n                                result.isFetchResult = true;\r\n                                result.status = 'loading';\r\n                                result.loading = true;\r\n\r\n                                // handle async fetching\r\n                                result.then(\r\n                                    (x) => {\r\n                                        result.success = true;\r\n                                        result.loading = false;\r\n                                        result.status = 'success';\r\n                                        result.payload = x;\r\n                                        dummyDispatch();\r\n                                    },\r\n                                    (x) => {\r\n                                        result.fail = true;\r\n                                        result.loading = false;\r\n                                        result.status = 'fail';\r\n                                        result.payload = x;\r\n                                        dummyDispatch();\r\n                                    }\r\n                                );\r\n                            } else {\r\n                                result = {\r\n                                    isFetchResult: true,\r\n                                    status: 'success',\r\n                                    success: true,\r\n                                    payload: result,\r\n                                };\r\n                            }\r\n                        } else {\r\n                            // do not touch\r\n                        }\r\n                    } else {\r\n                        result = {\r\n                            status: 'success',\r\n                            success: true,\r\n                            payload: result,\r\n                        };\r\n                    }\r\n\r\n                    // clone fetching result to make sure mergedProps changed\r\n                    if (result && result.then && (result.success || result.fail)) {\r\n                        result = {\r\n                            isFetchResult: true,\r\n                            fail: result.fail,\r\n                            success: result.success,\r\n                            status: result.status,\r\n                            payload: result.payload\r\n                        };\r\n                    }\r\n\r\n                    props.$fetch = result;\r\n                }\r\n                return props;\r\n            });\r\n            return connect(\r\n                (state) => ({state}),\r\n                null,\r\n                ({state}, dispatchProps, ownProps) => reselect(mapper(state, actionWrappers, ownProps)) || ownProps\r\n            );\r\n        },\r\n        /**\r\n         * register single action\r\n         */\r\n        action(key, action, options) {\r\n            if (!(action instanceof Function)) {\r\n                options = action;\r\n                action = identity;\r\n            }\r\n\r\n            registerActions(null, set(pathToLens(key), [action, options], {}));\r\n            return app;\r\n        },\r\n        /**\r\n         * add custom reducers. This is helpful for 3rd lib which need reducer (Router, Log...)\r\n         */\r\n        reducer(value) {\r\n            customReducer = value instanceof Function ? value : combineReducers(value);\r\n            return app;\r\n        },\r\n        /**\r\n         * dispatch custom action\r\n         */\r\n        dispatch(...args) {\r\n            dispatch(...args);\r\n            return app;\r\n        },\r\n        debounce,\r\n        /**\r\n         *\r\n         */\r\n        subscribe(subscriber) {\r\n            return store.subscribe((...args) => subscriber(store.getState(), ...args));\r\n        },\r\n        /**\r\n         * register multiple actions\r\n         */\r\n        actions(model) {\r\n            registerActions(null, model);\r\n            return app;\r\n        },\r\n        /**\r\n         * create new selector\r\n         */\r\n        selector(...args) {\r\n            return createSelector(...args);\r\n        },\r\n        /**\r\n         * get current state\r\n         */\r\n        getState() {\r\n            return store.getState();\r\n        },\r\n        /**\r\n         * run test for specific action\r\n         */\r\n        test(actionPath, ...args) {\r\n            //console.log('[test]', actionPath);\r\n            const action = view(pathToLens(actionPath), actionWrappers);\r\n            return action(...args);\r\n        },\r\n    };\r\n\r\n    return app;\r\n}"]}